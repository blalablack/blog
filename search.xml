<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[事件]]></title>
      <url>/blog/2017/08/29/%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>主要介绍了原生事件的概念和兼容方法。<a id="more"></a></p>
<h3 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h3><p>1、传统方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	event<span class="comment">//事件对象</span></div><div class="line">	<span class="keyword">this</span><span class="comment">//btn,引用当前元素</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//移除</span></div><div class="line">btn.onclick=<span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<p>特点：只能绑定一个，后边的会覆盖前面的<br>2、addEventListener<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.addEventListener(<span class="string">"click"</span>,handler,<span class="literal">false</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	event<span class="comment">//事件对象</span></div><div class="line">	<span class="keyword">this</span><span class="comment">//btn,引用当前元素</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//移除</span></div><div class="line">btn.removeEventListener(<span class="string">"click"</span>,handler,<span class="literal">false</span>);</div></pre></td></tr></table></figure></p>
<p>特点：绑定多个，按顺序执行。匿名函数解除不了。<br>3、attachEvent(IE)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>,handler);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	event<span class="comment">//事件对象</span></div><div class="line">	<span class="keyword">this</span><span class="comment">//window</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//移除</span></div><div class="line">btn.detachEvent(<span class="string">"onclick"</span>,handler)</div></pre></td></tr></table></figure></p>
<p>特点：绑定多个，按倒序触发。click=&gt;onclick。this指向全局。</p>
<h3 id="一、事件对象"><a href="#一、事件对象" class="headerlink" title="一、事件对象"></a>一、事件对象</h3><p>在触发DOM上的某个事件时，会产生一个事件对象event，它包含着所有与事件有关的信息。事件对象(event)都可以在事件处理函数中访问到。<br>1、type：事件类型，可以用来判断触发的是那个事件。（ie,dom）<br>2、target:事件源对象：哪个元素触发的。（dom,ie是srcElement）<br>3、currentTarget:注册事件的那个元素。（dom,ie没有）</p>
<h3 id="二、跨浏览器的事件处理方法"><a href="#二、跨浏览器的事件处理方法" class="headerlink" title="二、跨浏览器的事件处理方法"></a>二、跨浏览器的事件处理方法</h3><p>这是《javascript高级程序设计》提供的方法，基本解决了浏览器兼容问题。也是对前面的总结。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil=&#123;</div><div class="line">	<span class="comment">//添加事件</span></div><div class="line">	addHandler:<span class="keyword">function</span>(element,<span class="keyword">type</span>,handler)&#123;</div><div class="line">		<span class="keyword">if</span>(element<span class="variable">.addEventListener</span>)&#123;</div><div class="line">			element<span class="variable">.addEventListener</span>(<span class="keyword">type</span>,handler,false);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element<span class="variable">.attachEvent</span>)&#123;</div><div class="line">			element<span class="variable">.attachEvent</span>(<span class="string">"on"</span>+<span class="keyword">type</span>,handler);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			element[<span class="string">"on"</span>+<span class="keyword">type</span>]=handler;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//移除事件</span></div><div class="line">	removeHandler:<span class="keyword">function</span>(element,<span class="keyword">type</span>,handler)&#123;</div><div class="line">		<span class="keyword">if</span>(element<span class="variable">.removeEventListener</span>)&#123;</div><div class="line">			element<span class="variable">.removeEventListener</span>(<span class="keyword">type</span>,handler,false);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element<span class="variable">.detachEvent</span>)&#123;</div><div class="line">			element<span class="variable">.detachEvent</span>(<span class="string">"on"</span>+<span class="keyword">type</span>,handler);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			element[<span class="string">"on"</span>+<span class="keyword">type</span>]=<span class="literal">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//获取事件对象</span></div><div class="line">	getEvent:<span class="keyword">function</span>(<span class="keyword">event</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">event</span>?<span class="keyword">event</span>:window<span class="variable">.event</span>;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//获取事件源对象</span></div><div class="line">	getTarget:<span class="keyword">function</span>(<span class="keyword">event</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">event</span><span class="variable">.target</span>||<span class="keyword">event</span><span class="variable">.srcElement</span>;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//阻止默认事件</span></div><div class="line">	preventDefault:<span class="keyword">function</span>(<span class="keyword">event</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">event</span><span class="variable">.preventDefault</span>)&#123;</div><div class="line">			<span class="keyword">event</span><span class="variable">.preventDefault</span>();</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">event</span><span class="variable">.returnValue</span>=false;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//阻止冒泡</span></div><div class="line">	stopPropagation:<span class="keyword">function</span>(<span class="keyword">event</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">event</span><span class="variable">.stopPropagation</span>)&#123;</div><div class="line">			<span class="keyword">event</span><span class="variable">.stopPropagation</span>();</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">event</span><span class="variable">.cancelBubble</span>=true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>应用：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">function <span class="title">showValue</span>(<span class="params"><span class="keyword">event</span></span>)</span>&#123;</div><div class="line">	<span class="comment">//获取事件对象</span></div><div class="line">	e=EventUtil.getEvent(<span class="keyword">event</span>);</div><div class="line">	<span class="comment">//阻止冒泡</span></div><div class="line">	EventUtil.stopPropagation(e);</div><div class="line">	<span class="comment">//获取事件源对象</span></div><div class="line">	<span class="keyword">var</span> eTarget=EventUtil.getTarget(e);</div><div class="line">	console.log(eTarget.<span class="keyword">value</span>)</div><div class="line">&#125;</div><div class="line">EventUtil.addHandler(div,<span class="string">"click"</span>,showValue)</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[迭代方法]]></title>
      <url>/blog/2017/08/16/%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>主要介绍了ES5的几个迭代方法（filter、map、forEach、every、some）<a id="more"></a></p>
<h3 id="一、map方法"><a href="#一、map方法" class="headerlink" title="一、map方法"></a>一、map方法</h3><p>map方法返回一个数组，这个新数组的每一项依次对应原数组。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arrMap=arr.map(<span class="function"><span class="keyword">function</span><span class="params">(item,index,array)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> item*<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line">arrMap<span class="comment">//[2,4,6,8,10]</span></div></pre></td></tr></table></figure></p>
<p>不会改变原数组，返回新数组</p>
<h3 id="二、forEach方法"><a href="#二、forEach方法" class="headerlink" title="二、forEach方法"></a>二、forEach方法</h3><p>forEach方法没有返回值,跟for差不多，不能像for一样break打断全部，可以return结束本次。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">	<span class="comment">//在这里面执行某些操作</span></div><div class="line">	<span class="keyword">if</span>(index===<span class="number">3</span>)&#123;</div><div class="line">		<span class="built_in">console</span>.log(item);</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>不会改变原数组，也不返回新数组，只是针对数组的每一项做操作。</p>
<h3 id="三、filter方法"><a href="#三、filter方法" class="headerlink" title="三、filter方法"></a>三、filter方法</h3><p>filter方法返回新的数组（符合条件项组成的），用来查询符合某些条件的所有数组项。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arrFilter=arr.filter(<span class="function"><span class="keyword">function</span><span class="params">(item,index,array)</span></span>&#123;</div><div class="line">	<span class="comment">//返回所有数组项大于2的</span></div><div class="line">	<span class="keyword">return</span> item&gt;<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line">arrFilter<span class="comment">//[3,4,5]</span></div></pre></td></tr></table></figure></p>
<p>不会改变原数组，用来筛选挺好</p>
<h3 id="四、every方法"><a href="#四、every方法" class="headerlink" title="四、every方法"></a>四、every方法</h3><p>对数组的每一项运行给定函数，如果每一项都返回true，则返回true。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arrEvery=arr.every(<span class="function"><span class="keyword">function</span><span class="params">(item,index,array)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> item&gt;<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line">arrEvery<span class="comment">//flase</span></div></pre></td></tr></table></figure></p>
<p>不会改变原数组，返回值true或false。</p>
<h3 id="五、some方法"><a href="#五、some方法" class="headerlink" title="五、some方法"></a>五、some方法</h3><p>和every类似，只要有一项返回true，则返回true。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arrSome=arr.some(<span class="function"><span class="keyword">function</span><span class="params">(item,index,array)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> item&gt;<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line">arrSome<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>注：上面的函数参数都是可选的。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[继承]]></title>
      <url>/blog/2017/08/07/%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p>对《JavaScript高级程序设计》关于继承的总结<a id="more"></a></p>
<h3 id="一、单独使用原型链实现继承"><a href="#一、单独使用原型链实现继承" class="headerlink" title="一、单独使用原型链实现继承"></a>一、单独使用原型链实现继承</h3><h4 id="1、特点："><a href="#1、特点：" class="headerlink" title="1、特点："></a>1、特点：</h4><p>父类型的实例是子类型的原型，所有的子类型实例共享父实例的方法属性。<br>问题：子类型实例化时不能向父类传参，对于引用类型的值时，改一个全改。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span></span>&#123;</div><div class="line">	this.name=name;</div><div class="line">	this.color=[<span class="string">"black"</span>,<span class="string">"white"</span>,<span class="string">"yellow"</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">(age)</span></span>&#123;</div><div class="line">	this.age=age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">Parent</span>.prototype=<span class="keyword">new</span> Person(<span class="string">"lee"</span>);</div><div class="line"><span class="keyword">Parent</span>.prototype.constructor=<span class="keyword">Parent</span>;</div><div class="line">parent1=<span class="keyword">new</span> <span class="keyword">Parent</span>(<span class="number">30</span>);</div><div class="line">parent2=<span class="keyword">new</span> <span class="keyword">Parent</span>(<span class="number">32</span>);</div></pre></td></tr></table></figure></p>
<p>注：所有对象都是Object构造函数的实例，原型链的最顶端就是Object，原型对象也是对象。</p>
<h3 id="二、构造函数绑定"><a href="#二、构造函数绑定" class="headerlink" title="二、构造函数绑定"></a>二、构造函数绑定</h3><h4 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点:"></a>1、特点:</h4><p>在子类构造函数内部调用超类构造函数，就是在子类中把父类所有的属性方法复制一遍。<br>问题：跟原型无关，子类无法使用父类原型的方法，所有的方法只能使用构造函数的方法，但可以自由传参，所有实例都有自己的一份属性方法，没有引用类型的问题。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	Human.call(<span class="keyword">this</span>,name);</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age,color</span>)</span>&#123;</div><div class="line">	Person.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">	<span class="keyword">this</span>.color=<span class="built_in">color</span>;</div><div class="line">&#125;</div><div class="line">parent1=<span class="keyword">new</span> Parent(<span class="string">"lee"</span>,<span class="number">30</span>,<span class="string">"black"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="三、组合方式实现继承"><a href="#三、组合方式实现继承" class="headerlink" title="三、组合方式实现继承"></a>三、组合方式实现继承</h3><h4 id="1、特点：-1"><a href="#1、特点：-1" class="headerlink" title="1、特点："></a>1、特点：</h4><p>结合了原型链和构造函数的优点，私有的属性方法写在构造函数中，共享的属性方法写在原型对象中。<br>问题：在把子构造函数的原型间接指向父构造函数的原型过程中多调用了一次父超类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.color=[<span class="string">"black"</span>,<span class="string">"white"</span>,<span class="string">"yellow"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);<span class="comment">//把父类的属性方法拷贝了一份</span></div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">Parent.prototype=<span class="keyword">new</span> Person();<span class="comment">//多调用的那一次</span></div><div class="line">Parent.prototype.constructor=Parent;</div><div class="line">parent1=<span class="keyword">new</span> Parent(<span class="string">"lee"</span>,<span class="number">24</span>);</div></pre></td></tr></table></figure></p>
<h3 id="四、寄生组合式继承"><a href="#四、寄生组合式继承" class="headerlink" title="四、寄生组合式继承"></a>四、寄生组合式继承</h3><h4 id="1、特点：-2"><a href="#1、特点：-2" class="headerlink" title="1、特点："></a>1、特点：</h4><p>利用空对象代替父类实例解决了调用两次父构造函数的问题。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">parent,child</span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> temp=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">	temp.prototype=<span class="built_in">parent</span>.prototype;</div><div class="line">	child.prototype=<span class="keyword">new</span> temp();</div><div class="line">	child.prototype.constructor=child;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.color=[<span class="string">"black"</span>,<span class="string">"white"</span>,<span class="string">"yellow"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">inheritPrototype(Person,Parent);</div><div class="line">parent1=<span class="keyword">new</span> Parent(<span class="string">"lee"</span>,<span class="number">24</span>);</div></pre></td></tr></table></figure></p>
<h3 id="五、拷贝继承"><a href="#五、拷贝继承" class="headerlink" title="五、拷贝继承"></a>五、拷贝继承</h3><h4 id="1、特点：-3"><a href="#1、特点：-3" class="headerlink" title="1、特点："></a>1、特点：</h4><p>把父构造函数原型上的方法属性复制一份给子构造函数原型来实现继承。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">parent,child</span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> p=<span class="built_in">parent</span>.prototype;</div><div class="line">	<span class="built_in">var</span> c=child.prototype;</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">var</span> i <span class="keyword">in</span> p)&#123;</div><div class="line">		c[i]=p[i];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.color=[<span class="string">"black"</span>,<span class="string">"white"</span>,<span class="string">"yellow"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">extendCopy(Person,Parent);</div><div class="line">parent1=<span class="keyword">new</span> Parent(<span class="string">"lee"</span>,<span class="number">24</span>);</div></pre></td></tr></table></figure></p>
<p>各自有各自的原型，只是子的把父的原型复制了一遍，因为都是在原型的操作（实例不能直接修改原型）不涉及引用类型的问题。</p>
<h3 id="六、不使用构造函数继承"><a href="#六、不使用构造函数继承" class="headerlink" title="六、不使用构造函数继承"></a>六、不使用构造函数继承</h3><h4 id="1、原型式继承"><a href="#1、原型式继承" class="headerlink" title="1、原型式继承"></a>1、原型式继承</h4><h5 id="1、使用函数的方式实现"><a href="#1、使用函数的方式实现" class="headerlink" title="1、使用函数的方式实现"></a>1、使用函数的方式实现</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">	name:<span class="string">"lee"</span>,</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	F.prototype=<span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="keyword">parent</span>=object(person);</div></pre></td></tr></table></figure>
<p>这个object函数只做了一件事，把子对象的原型指向父对象，这样子对象就能使用父对象的方法了。</p>
<h5 id="2、Object-create-方法实现"><a href="#2、Object-create-方法实现" class="headerlink" title="2、Object.create()方法实现"></a>2、Object.create()方法实现</h5><p><code>Object.create()</code>方法接受两个参数，在只有一个参数的情况下，它和上面的object方法的作用是一致的。  </p>
<p><code>Object.create()</code>的第二个参数和<code>Object.defineProperties()</code>方法的第二个参数格式相同,通过这样方式定义的属性是自有属性，但是默认不可重写。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">	<span class="attr">name</span>:<span class="string">"lee"</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> parent=<span class="built_in">Object</span>.create(person,&#123;</div><div class="line">	<span class="attr">name</span>:&#123;</div><div class="line">		<span class="attr">value</span>:<span class="string">"li"</span>,</div><div class="line">		<span class="attr">writable</span>:<span class="literal">true</span><span class="comment">//设置为可以重写</span></div><div class="line">	&#125;,</div><div class="line">	<span class="attr">say</span>:&#123;</div><div class="line">		<span class="attr">value</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line">parent.say();<span class="comment">//li</span></div></pre></td></tr></table></figure></p>
<h4 id="2、浅拷贝"><a href="#2、浅拷贝" class="headerlink" title="2、浅拷贝"></a>2、浅拷贝</h4><p>特点：把父对象的方法属性拷贝到子对象上。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> c=&#123;&#125;;</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">var</span> i <span class="keyword">in</span> p)&#123;</div><div class="line">		c[i]=p[i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"><span class="built_in">var</span> person=&#123;</div><div class="line">	<span class="attribute">name</span>:<span class="string">"lee"</span>,</div><div class="line">&#125;</div><div class="line"><span class="built_in">var</span> <span class="built_in">parent</span>=extendCopy(person);</div></pre></td></tr></table></figure></p>
<p>在涉及引用类型的值时，会出现共享的问题（只是复制了地址）。</p>
<h4 id="3、深拷贝"><a href="#3、深拷贝" class="headerlink" title="3、深拷贝"></a>3、深拷贝</h4><p>把包含引用类型值是递归调用浅拷贝。这要操作之后子类拥有所有父类的内容，子父相互独立可以放心使用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function deepCopy(p,<span class="built_in">c</span>)&#123;</div><div class="line">	<span class="keyword">var</span> <span class="built_in">c</span>=<span class="built_in">c</span>||&#123;&#125;;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> p)&#123;</div><div class="line">		<span class="keyword">if</span>(typeof p[i]===<span class="string">"object"</span>)&#123;</div><div class="line">			<span class="built_in">c</span>[i]=(p[i].constructor===<span class="type">Array</span>)?[]:&#123;&#125;;<span class="comment">//确定是否数组</span></div><div class="line">			deepCopy(p[i],<span class="built_in">c</span>[i]);<span class="comment">//递归调用</span></div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="built_in">c</span>[i]=p[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">c</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">	name:<span class="string">"lee"</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> parent=deepCopay(person);</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[css知识点]]></title>
      <url>/blog/2017/08/03/css%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>一些css知识和使用技巧的总结<a id="more"></a></p>
<h3 id="一、-nth-of-type-n-和-nth-child-n"><a href="#一、-nth-of-type-n-和-nth-child-n" class="headerlink" title="一、:nth-of-type(n)和:nth-child(n)"></a>一、:nth-of-type(n)和:nth-child(n)</h3><p>p:nth-of-type(2)：选择属于其父元素第二个 </p><p> 元素的每个 </p><p> 元素。<br>p:nth-child(2)：选择属于其父元素的唯一子元素的每个 </p><p> 元素。<br>字面意思就是:nth-of-type(n)是分类的，而:nth-child(n)不分类（只要是子元素都算）。<br>例如：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;div id='d1'&gt;</span></div><div class="line">	<span class="params">&lt;p&gt;</span>我是p<span class="params">&lt;/p&gt;</span></div><div class="line">	<span class="params">&lt;div&gt;</span>我是div<span class="params">&lt;/div&gt;</span></div><div class="line">	<span class="params">&lt;p&gt;</span>我是p<span class="params">&lt;/p&gt;</span></div><div class="line">	<span class="params">&lt;div&gt;</span>我是div<span class="params">&lt;/div&gt;</span></div><div class="line"><span class="params">&lt;/div&gt;</span></div><div class="line"><span class="meta">#d1 div:nth-of-type(1)&#123;</span></div><div class="line"><span class="symbol">	background:</span> <span class="meta">#ddd;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/blog/myimages/cssPointer/p1.png" alt="效果"><br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;div id='d1'&gt;</span></div><div class="line">	<span class="params">&lt;p&gt;</span>我是p<span class="params">&lt;/p&gt;</span></div><div class="line">	<span class="params">&lt;div&gt;</span>我是div<span class="params">&lt;/div&gt;</span></div><div class="line">	<span class="params">&lt;p&gt;</span>我是p<span class="params">&lt;/p&gt;</span></div><div class="line">	<span class="params">&lt;div&gt;</span>我是div<span class="params">&lt;/div&gt;</span></div><div class="line"><span class="params">&lt;/div&gt;</span></div><div class="line"><span class="meta">#d1 div:nth-child(1)&#123;</span></div><div class="line"><span class="symbol">	background:</span> <span class="meta">#ddd;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/blog/myimages/cssPointer/p2.png" alt="效果"><br>就是带着type的都会分类，不带的不会分类，子元素都算上。感觉:nth-of-type(n)比较符合使用习惯。<br>注：这些都不能和类选择器，id选择器结合使用。</p>
<h3 id="二、hover的一个妙用"><a href="#二、hover的一个妙用" class="headerlink" title="二、hover的一个妙用"></a>二、hover的一个妙用</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">	&lt;<span class="built_in">li</span>&gt;第一个<span class="built_in">li</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">	&lt;<span class="built_in">li</span> class=<span class="string">"second"</span>&gt;第二个<span class="built_in">li</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">	&lt;<span class="built_in">li</span>&gt;第三个<span class="built_in">li</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">	&lt;<span class="built_in">li</span>&gt;第四个<span class="built_in">li</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">ul:hover .<span class="built_in">second</span>&#123;</div><div class="line">	<span class="built_in">background</span>:#ddd;</div><div class="line">	<span class="built_in">color</span>:#cc80dd;</div><div class="line">	padding-left:200px;</div><div class="line">	margin-top: 100px;</div><div class="line">	<span class="built_in">height</span>:100px;</div><div class="line">&#125;</div><div class="line"><span class="built_in">li</span>&#123;</div><div class="line">	transition:all 1s;</div><div class="line">	<span class="built_in">height</span>:20px;</div><div class="line">	<span class="comment">/*其余的都有默认值*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>意思是#d1的hover事件但是#d1的子元素样式改变(所有的样式改变都ok)。所有的浏览器都支持，之要用js写的功能，css就能搞定，是不是很厉害啊。<br>注：所有hover之后的样式，hover之前都要有，不然会闪回。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[创建对象]]></title>
      <url>/blog/2017/08/02/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>对《JavaScript高级程序设计》关于创建对象方法的总结<a id="more"></a></p>
<h3 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h3><p>概述：在js中工厂模式可以看做是一种函数，用来封装创建对象的细节，最后返回一个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">funciton Person(name,age)&#123;</div><div class="line">	<span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.name=name;</div><div class="line">	o.age=age;</div><div class="line">	o.intr=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="二、构造函数模式"><a href="#二、构造函数模式" class="headerlink" title="二、构造函数模式"></a>二、构造函数模式</h3><h4 id="1、理解构造函数"><a href="#1、理解构造函数" class="headerlink" title="1、理解构造函数"></a>1、理解构造函数</h4><p>构造函数也是函数的一种，只不过具有创建对象的作用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">	<span class="keyword">this</span>.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"is"</span>+<span class="keyword">this</span>.age)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Lee"</span>,<span class="number">24</span>);</div></pre></td></tr></table></figure></p>
<p>Person构造函数创建person实例时，new操作符做了这样几件事：<br>1、创建一个新对象。<br>2、将对象进行[[prototype]]连接。<br>3、将Person的this指向person1。<br>4、按照构造函数初始化person1(添加属性方法)。<br>5、返回person1这个新对象。<br>实例有一个constructor属性指向他的构造函数Person。<br><code>person1.constructor==Person</code><br>instanceof用来检测对象(只要是对象就行)的类型。<br><code>person1 instanceof Person;//true</code></p>
<h4 id="2、构造函数当做函数。"><a href="#2、构造函数当做函数。" class="headerlink" title="2、构造函数当做函数。"></a>2、构造函数当做函数。</h4><h5 id="1、直接调用。"><a href="#1、直接调用。" class="headerlink" title="1、直接调用。"></a>1、直接调用。</h5><p>不使用new操作符来调用构造函数时，this指向window，属性和方法都会添加给window对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=<span class="string">"lee"</span>;</div><div class="line">&#125;</div><div class="line">Fn();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);<span class="comment">//lee</span></div></pre></td></tr></table></figure></p>
<p>在全局调用，这个没啥好说的，会把name添加到window上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=<span class="string">"lee"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	Fn();</div><div class="line">	<span class="keyword">this</span>.age=<span class="number">24</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ha=<span class="keyword">new</span> anFn();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);<span class="comment">//lee</span></div></pre></td></tr></table></figure></p>
<p>这种Fn是在anFn内部调用，在Fn()执行时this绑定没完成，所以这时的this还是指window，从而把属性方法绑定在window上。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=<span class="string">"lee"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anFn</span><span class="params">()</span></span>&#123;</div><div class="line">	Fn.apply(<span class="keyword">this</span>);</div><div class="line">	<span class="keyword">this</span>.age=<span class="number">24</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="2、call、apply绑定"><a href="#2、call、apply绑定" class="headerlink" title="2、call、apply绑定"></a>2、call、apply绑定</h5><p>使用call、apply在某个对象中调用构造函数，这也是构造函数继承的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=<span class="string">"lee"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Fn.call(o);</div><div class="line"><span class="built_in">console</span>.log(o.name);<span class="comment">//lee</span></div></pre></td></tr></table></figure></p>
<p>这两个方法的第一个参数就是this绑定的对象,在非严格模式下null或者undefined,将会使用全局对象代替。<br>apply的第二个参数是一个数组，在调用时会把这个数组内容转换为参数。可以用来展开数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> args=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(x+y+z);</div><div class="line">&#125;</div><div class="line">f.apply(<span class="literal">null</span>,args)<span class="comment">//6</span></div></pre></td></tr></table></figure></p>
<h4 id="3、构造函数的特点"><a href="#3、构造函数的特点" class="headerlink" title="3、构造函数的特点"></a>3、构造函数的特点</h4><p>1、构造函数的主要问题就是每个方法都要在实例上创建一遍。<br>2、可以自由的传递参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">	<span class="keyword">this</span>.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"is"</span>+<span class="keyword">this</span>.age)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"lee"</span>,<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"james"</span>,<span class="number">28</span>);</div></pre></td></tr></table></figure></p>
<p>上面我们创建了一个Person的构造函数，对于它的两个实例person1和person来说，say方法显然可以不用再每个对象中都创建一遍。那我们其实可以写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">	<span class="keyword">this</span>.say=say</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"lee"</span>,<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"james"</span>,<span class="number">28</span>);</div></pre></td></tr></table></figure></p>
<p>在这里person1和person2共享全局中的say，虽然这样不必在每个实例中都创建相同的say函数，但是把所有的共享方法放在全局中又不是最好的解决办法。于是原型模式就出现了。<br>注：感觉跟原型的原理是一样的，只不过原型的封装性好。</p>
<h3 id="三、原型模式"><a href="#三、原型模式" class="headerlink" title="三、原型模式"></a>三、原型模式</h3><h4 id="1、特点："><a href="#1、特点：" class="headerlink" title="1、特点："></a>1、特点：</h4><p>1、实例取得相同的属性（实例时不能传参）。<br>2、对于引用类型的值，所有实例共享同一个（改一个全改）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name=<span class="string">"lee"</span>;</div><div class="line">Person.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</div></pre></td></tr></table></figure></p>
<p>原型模式可以把共有的属性方法放在函数的原型中解决了构造函数每个实例都要创建相同方法属性的问题。</p>
<h4 id="2、关于原型的方法："><a href="#2、关于原型的方法：" class="headerlink" title="2、关于原型的方法："></a>2、关于原型的方法：</h4><p>1、<code>Object.getPrototyOf()</code>这个方法可以得到实例的原型。<code>Object.getPrototyOf(person1)</code><br>2、<code>isPrototypeOf()</code>用来判断某个原型对象和实例之间的关系。<code>Person.prototype.isPrototypeOf(person1)</code>。<br>3、<code>hasOwnProperty()</code>用来检测实例是否本地具有某个属性，还是继承自原型。<code>person1.hasOwnProperty(&quot;name&quot;)</code></p>
<h3 id="四、构造函数和原型链组合"><a href="#四、构造函数和原型链组合" class="headerlink" title="四、构造函数和原型链组合"></a>四、构造函数和原型链组合</h3><h4 id="1、特点：-1"><a href="#1、特点：-1" class="headerlink" title="1、特点："></a>1、特点：</h4><p>1、共享的属性方法放在原型对象中。<br>2、不共享的属性方法放在构造函数中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">constructor</span>:Person,</div><div class="line">	<span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"lee"</span>,<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"li"</span>,<span class="number">18</span>);</div></pre></td></tr></table></figure></p>
<p>这里person1、person2都有各自的name、age属性，同时他们又通过原型链共享say方法。这种方法结合了构造函数和原型链的优点，被广泛使用来创建对象。<br>注：这里使用字面量的形式重写了Person的原型，{}是Object创建的实例所以它的原型中的constructor自然指向Object构造函数，这里在{}内部重写constructor属性相当于覆盖了它原型链中的constructor。<strong>如果替换了原型对象天，一定要重新为这个新原型添加constructor属性</strong></p>
<h3 id="五、动态原型模式"><a href="#五、动态原型模式" class="headerlink" title="五、动态原型模式"></a>五、动态原型模式</h3><h4 id="1、特点：-2"><a href="#1、特点：-2" class="headerlink" title="1、特点："></a>1、特点：</h4><p>1、把上面的组合方法进行了更好的封装。<br>2、不能使用字面量的方式重写原型了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">"funciton"</span>)&#123;</div><div class="line">		Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"lee"</span>,<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"li"</span>,<span class="number">18</span>);</div></pre></td></tr></table></figure></p>
<p>if判断保证创建多个实例时，只进行一次原型修改，把上面的组合方法进行了巧妙的封装。<br>若重写原型对象，实例的创建必须在原型对象修改完毕之后，不然会发生原型隔离（抛弃已定义原型的方法）。这里在创建person1实例时,还没执行到if时实例已经完成了[[prototype]]连接，也就是person1实例已经有了他的原型对象，这是在进行字面量修改原型是没有用的，所以只能使用原型.的方式进行属性方法添加。</p>
<h3 id="六、寄生构造函数模式"><a href="#六、寄生构造函数模式" class="headerlink" title="六、寄生构造函数模式"></a>六、寄生构造函数模式</h3><h4 id="1、特点：-3"><a href="#1、特点：-3" class="headerlink" title="1、特点："></a>1、特点：</h4><p>1、跟工厂模式一样，其实就是一个包装函数，在函数的内部创建对象、为其添加属性方法然后返回这个对象。<br>2、只是在把函数的创建放在函数中，跟在外面创建对象没有什么不同，不涉及构造函数的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">funciton Person(name,age)&#123;</div><div class="line">	<span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.name=name;</div><div class="line">	o.age=age;</div><div class="line">	o.intr=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、使用场景；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> values=<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	<span class="comment">//传参</span></div><div class="line">	values.push.apply(values,<span class="built_in">arguments</span>);</div><div class="line">	values.toPipedString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> values;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr1=<span class="keyword">new</span> SpecialArry(<span class="string">"lee"</span>,<span class="string">"li"</span>);</div><div class="line">arr1.toPipedString();<span class="comment">//"lee|"</span></div></pre></td></tr></table></figure></p>
<p>我想创建好多带有特殊方法的数组，又不能改变原生的Array构造函数这是就可以使用这个模式。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[label]]></title>
      <url>/blog/2017/07/24/label/</url>
      <content type="html"><![CDATA[<p>这篇主要记录在label标签上绑定事件会触发两次的一个bug，还有记录看到一个不错的label的样式。<a id="more"></a></p>
<h2 id="一、label触发两次的bug"><a href="#一、label触发两次的bug" class="headerlink" title="一、label触发两次的bug"></a>一、label触发两次的bug</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> id=<span class="string">"d2"</span> name=<span class="string">"age"</span>&gt;&lt;<span class="keyword">label</span> <span class="keyword">for</span>=<span class="string">"d2"</span>&gt;年龄&lt;/<span class="keyword">label</span>&gt;</div><div class="line">&lt;<span class="keyword">label</span>&gt;&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> name=<span class="string">"age"</span>&gt;年龄&lt;/<span class="keyword">label</span>&gt;</div></pre></td></tr></table></figure>
<p>上面两种方式都可以实现label的效果，第二种省略了id和for也是可以的，简化了代码。对于事件绑定来说，你只要两种方式都绑定在input上就没有什么问题。但是如果你需要绑定在lable上，对于<code>&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;age&quot;&gt;年龄&lt;/label&gt;</code>这种来说就会触发两次。<br>解释：label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。<strong>当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</strong>也就是，当label执行click事件时，那么它会传递给input再执行一次同一click事件，而且事件源对象都是label。</p>
<h2 id="二、一个不错的样式"><a href="#二、一个不错的样式" class="headerlink" title="二、一个不错的样式"></a>二、一个不错的样式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">label</span>&#123;</div><div class="line">	<span class="attribute">cursor</span>: pointer;</div><div class="line">	<span class="attribute">display</span>: inline-block;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">label</span> <span class="selector-tag">span</span>&#123;</div><div class="line">	<span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">   	<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(0,0,0,0.15);</div><div class="line">   	<span class="attribute">border-radius</span>: <span class="number">100%</span>;</div><div class="line">   	<span class="attribute">display</span>: inline-block;</div><div class="line">   	<span class="attribute">height</span>: <span class="number">16px</span>;</div><div class="line">   	<span class="attribute">margin-right</span>: <span class="number">10px</span>;</div><div class="line">   	<span class="attribute">margin-top</span>: -<span class="number">1px</span>;</div><div class="line">   	<span class="attribute">vertical-align</span>: middle;</div><div class="line">   	<span class="attribute">width</span>: <span class="number">16px</span>;</div><div class="line">   	<span class="attribute">line-height</span>: <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">label</span> <span class="selector-tag">input</span>&#123;</div><div class="line">	<span class="attribute">display</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">label</span> <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> +<span class="selector-tag">span</span><span class="selector-pseudo">:after</span>&#123;</div><div class="line">	<span class="attribute">background-color</span>: <span class="number">#cc80dd</span>;</div><div class="line">   	<span class="attribute">border-radius</span>: <span class="number">100%</span>;</div><div class="line">   	<span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">   	<span class="attribute">display</span>: inline-block;</div><div class="line">   	<span class="attribute">height</span>: <span class="number">12px</span>;</div><div class="line">   	<span class="attribute">margin</span>: <span class="number">2px</span>;</div><div class="line">   	<span class="attribute">width</span>: <span class="number">12px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果：<img src="/blog/myimages/label/p1.png" alt="展示效果"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[探究this]]></title>
      <url>/blog/2017/07/16/%E6%8E%A2%E7%A9%B6this/</url>
      <content type="html"><![CDATA[<p>此篇结合是我在看《你不知道的JavaScript》对this绑定的一些心得体会和记录。<a id="more"></a></p>
<h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h2><h3 id="一、默认绑定"><a href="#一、默认绑定" class="headerlink" title="一、默认绑定"></a>一、默认绑定</h3><p>独立函数调用，函数直接使用不带任何修饰的函数引用进行调用.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">defaultFn();<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>本例中（非严格模式）this指向全局对象。默认邦定在其他规则无法应用时的默认规则。</p>
<h3 id="二、隐式绑定"><a href="#二、隐式绑定" class="headerlink" title="二、隐式绑定"></a>二、隐式绑定</h3><p>必须在对象内部包含一个指向函数的函数，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unTypeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">	<span class="attr">foo</span>:unTypeFn</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">obj.foo();<span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>在obj对象中包含一个unTypeFn的引用，在通过obj调用unTypeFn时，this被自然的绑定到obj上，没毛病。</p>
<h4 id="1、隐式丢失"><a href="#1、隐式丢失" class="headerlink" title="1、隐式丢失"></a>1、隐式丢失</h4><p>this绑定的最常见问题就是隐式绑定的函数会丢失绑定对象，也就是会应用默认绑定，从而把this绑定在全局对象上（非严格模式）。</p>
<h5 id="1、值传递"><a href="#1、值传递" class="headerlink" title="1、值传递"></a>1、值传递</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unTypeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">	<span class="attr">foo</span>:unTypeFn</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line"><span class="comment">//引用类型传递</span></div><div class="line">va c=obj.foo;</div><div class="line">c();<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>obj.foo并没有直接调用，而是把它的引用地址传递给了c,所以c实际上引用的是unTypeFn函数本身，这里是默认绑定规则this指向全局。</p>
<h5 id="2、参数传递"><a href="#2、参数传递" class="headerlink" title="2、参数传递"></a>2、参数传递</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unTypeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFn</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">	fn();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">	<span class="attr">foo</span>:unTypeFn</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line"><span class="comment">//把obj.foo当做参数传递</span></div><div class="line">dofn(obj.foo);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>参数传递和值传递类似,都不是直接调用obj.foo，而是把它当做值来传递。</p>
<h5 id="3、回调函数"><a href="#3、回调函数" class="headerlink" title="3、回调函数"></a>3、回调函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unTypeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">	<span class="attr">foo</span>:unTypeFn</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line"><span class="comment">//回调函数的例子</span></div><div class="line">setTimeout(obj.foo,<span class="number">1000</span>);<span class="comment">//2</span></div><div class="line">d1.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	obj.foo();</div><div class="line">&#125;,<span class="literal">false</span>);<span class="comment">//2</span></div><div class="line"><span class="comment">//绑定在DOM元素上了</span></div><div class="line">d1.addEventListener(<span class="string">"click"</span>,obj.foo,<span class="literal">false</span>);<span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>这两个都是回调函数的例子感觉跟上面的两个还是一回事，都不是立即调用，都是当做值来传递，这样会发生隐式邦定丢失。</p>
<h3 id="三、显式绑定"><a href="#三、显式绑定" class="headerlink" title="三、显式绑定"></a>三、显式绑定</h3><p>在某个对象上直接强制调用函数，使用js内部的call和apply方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">2</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">typeFn.call(obj);<span class="comment">//1</span></div><div class="line"><span class="comment">//这里可以改变this绑定的对象</span></div><div class="line">typeFn.call(obj1);<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>call和apply方法是立即执行的，那么在多次调用这个方法是就可能改变this绑定的对象，于是就出现了显示绑定的变种——硬绑定的方法。</p>
<h4 id="1、硬绑定"><a href="#1、硬绑定" class="headerlink" title="1、硬绑定"></a>1、硬绑定</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeFn</span></span>()&#123;</div><div class="line">	console.log(<span class="built_in">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	a:<span class="type">1</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1=&#123;</div><div class="line">	a:<span class="type">2</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">1</span>=typeFn.bind(obj);</div><div class="line"><span class="keyword">new</span><span class="type">1</span>();<span class="comment">//1</span></div><div class="line"><span class="comment">//之后你就可以尽情的操作new1了，都不会改变typeFn绑定在obj上的事实</span></div><div class="line"><span class="keyword">new</span><span class="type">1</span>.bind(obj1);</div><div class="line"><span class="keyword">new</span><span class="type">1</span>();<span class="comment">//1</span></div><div class="line"><span class="keyword">new</span><span class="type">1</span>.call(obj1)<span class="comment">//1;</span></div></pre></td></tr></table></figure>
<p>ES5提供里内置的bind方法，返回一个新的绑定你指定this的函数，可以方便的进行硬绑定。new1.bind(obj).bind(obj1)是没啥用的他只会执行第一个。</p>
<h3 id="四、new绑定"><a href="#四、new绑定" class="headerlink" title="四、new绑定"></a>四、new绑定</h3><p>//待议</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[web存储机制]]></title>
      <url>/blog/2017/07/13/web%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>HTML5提供了两种客户端存储数据的新方法:<br>1、localStorage-没有时间限制的数据存储<br>2、sessionStorage-针对一个session（一个标签页）的数据存储。<br>这篇文章主要介绍这两个新方法和对比俩个方法的不同，和一些实际的应用<a id="more"></a></p>
<h2 id="一、localStorage"><a href="#一、localStorage" class="headerlink" title="一、localStorage"></a>一、localStorage</h2><h3 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h3><p>localStorage即本地储存，可以长久保存整个网站的数据，保存的数据没有过期时间，直到手动清除。</p>
<h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><p>（1）同源策略限制。在同一协议、同一主机名和同一端口下的所有页面都可以访问通过localStorage存储的数据。<br>（2）在本地浏览器储存，不会涉及到服务器。<br>（3）永久保存。数据没有过期时间，直到手动清除（浏览器清缓存也不行）。<br>（4）储存方式。采用key,value的方式，而且value的值必学是string类型（传入其他类型会转化为string类型）。<br>（5）不同浏览器不能相互访问。</p>
<h3 id="3、使用场景"><a href="#3、使用场景" class="headerlink" title="3、使用场景"></a>3、使用场景</h3><p>1、多页面访问相同数据。2、数据较大时的临时储存。</p>
<h2 id="二、sessionStorage"><a href="#二、sessionStorage" class="headerlink" title="二、sessionStorage"></a>二、sessionStorage</h2><h3 id="1、说明-1"><a href="#1、说明-1" class="headerlink" title="1、说明"></a>1、说明</h3><p>sessionStorage用于保存一个窗口或标签页的数据，关闭之后数据会被清除。</p>
<h3 id="2、特点-1"><a href="#2、特点-1" class="headerlink" title="2、特点"></a>2、特点</h3><p>（1）单标签页限制。sessionStorage操作限制在单标签页(仅指顶层标签页)中，不在一个标签页中无法访问数据，这也是它和localStorage的区别之一。<br>（2）在本地浏览器储存，不会涉及到服务器。<br>（3）储存方式。采用key,value的方式，而且value的值必学是string类型（传入其他类型会转化为string类型）。<br>（4）关闭窗口或标签页数据清空。<br>（5）同一顶级标签页下的不同页面（只要不是通过下面方法打开的）在打开是可以访问顶级标签页的数据，但也就是这是能联系，之后他们之间不会有任何关联。<br>（6）不同浏览器不能相互访问。</p>
<h3 id="3、使用场景-1"><a href="#3、使用场景-1" class="headerlink" title="3、使用场景"></a>3、使用场景</h3><p>sessionStorage就是用在单页面应用中使用。</p>
<h4 id="单标签页解释。"><a href="#单标签页解释。" class="headerlink" title="单标签页解释。"></a>单标签页解释。</h4><p>这里的标签页是指顶层标签页，即从顶层通过链接打开的新页面（新页面下面的页面）都算是这个标签页中的。<br>浏览器新标签（顶层）的打开方式：<br>  1、输入网址打开。<br>  2、右键打开新标签页。<br>  3、f12 open in new tab。<br>这些都算是打开一个新的顶层标签页，这些新的标签页通过sessionStorage储存的数据不共享。这种单标签页限制区别于localStorage。  </p>
<h2 id="三、storage事件"><a href="#三、storage事件" class="headerlink" title="三、storage事件"></a>三、storage事件</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>无论是对sessionStorage还是localStorage进行操作，只要是对storage对象进行任何修改都会触发storage事件。</p>
<h3 id="2、限制"><a href="#2、限制" class="headerlink" title="2、限制"></a>2、限制</h3><p>1、目前chrome并不支持在当前页触发，只能检测同源页面，单页面应用就gg了。<br>2、目前chrome重复载入相同数据也不触发，监听事件时要小心，不要怀疑世界了。<br>例如：我现在有同源的A和B两个页面，使用chrome改变A的localStorage，B页面会触发onstorage事件，但是A页面并不会触发。在A页面设置<code>localStorage.timeCout=5</code>，再次<code>localStorage.timeCout=5</code>,B页面不会触发。</p>
<h3 id="2、改进方法"><a href="#2、改进方法" class="headerlink" title="2、改进方法"></a>2、改进方法</h3><h4 id="1、重写setItem方法。"><a href="#1、重写setItem方法。" class="headerlink" title="1、重写setItem方法。"></a>1、重写setItem方法。</h4><p>localStorage.setItem(“name”,”Li”);这样和localStorage.name（对象点方法）相同的，所以我们就可以重写一下setItem方法，在页面调用setItem时就可以在本页面检测到这个事件啦。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在替换之前记录一下,给下面使用</span></div><div class="line"><span class="keyword">var</span> SetItem=localStorage.setItem;</div><div class="line">localStorage.setItem=<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</div><div class="line">	<span class="comment">//创建事件对象</span></div><div class="line">	<span class="keyword">var</span> setItemEvent=<span class="keyword">new</span> Event(<span class="string">"setItemEvent"</span>);</div><div class="line">	setItemEvent.value=value;</div><div class="line">	setItemEvent.key=key;</div><div class="line">	<span class="comment">//手动触发setItemEvent事件</span></div><div class="line">	<span class="built_in">window</span>.dispatchEvent(setItemEvent);</div><div class="line">	<span class="comment">//执行原方法，是还没重写之前的，这里的this指Storage。</span></div><div class="line">	SetItem.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"setItemEvent"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(e.key=<span class="string">"xx"</span>)&#123;</div><div class="line">		<span class="built_in">console</span>.log(e.value);</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>注：方法里的SetItem.apply(this,arguments)把SetItem方法绑定到Storage对象上，这样才能执行，要是SetItem()报Uncaught TypeError: Illegal invocation这个错。SetItem()相当于把这个Storage对象的setItem方法绑定到window上执行，是不行的。举个例子:<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d=<span class="built_in">document</span>.getElementById;</div><div class="line"><span class="keyword">var</span> c=d(<span class="string">"d1"</span>);</div><div class="line"><span class="comment">//报错：Uncaught TypeError: Illegal invocation。未捕获的类型错误：非法调用</span></div></pre></td></tr></table></figure></p>
<p>其实就是这样<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d=<span class="built_in">document</span>.getElementById;</div><div class="line"><span class="keyword">var</span> c=d.call(<span class="built_in">window</span>,<span class="string">"d1"</span>);</div></pre></td></tr></table></figure></p>
<p>d1的DOM元素应该在document对象中，你非得给人绑定到window对象中肯定是不合适的。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d=<span class="built_in">document</span>.getElementById;</div><div class="line"><span class="keyword">var</span> c=d.call(<span class="built_in">document</span>,<span class="string">"d1"</span>);</div></pre></td></tr></table></figure></p>
<p>这样你在试试</p>
<h4 id="2、添加数据变的作为事件监听"><a href="#2、添加数据变的作为事件监听" class="headerlink" title="2、添加数据变的作为事件监听"></a>2、添加数据变的作为事件监听</h4><p>例如：你想获取每次count的值，但是这个count的变化又是没有规律的（有时变有时不变），对于chrome来说重复载入相同数据不会触发事件，就会很尴尬。那么你就可以在每次改变count之后再添加一个每次都变好的change数据，这样你就可以通过监听change来获取每次count的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	localStorage.count=<span class="number">3</span>；</div><div class="line">	localStorage.change=+<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">&#125;</div><div class="line"><span class="comment">/*监听事件*/</span></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"storage"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(e.key==<span class="string">"change"</span>)&#123;</div><div class="line">           <span class="keyword">var</span> count=localStorage.count;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<h2 id="四、localstorage应用实例"><a href="#四、localstorage应用实例" class="headerlink" title="四、localstorage应用实例"></a>四、localstorage应用实例</h2><h3 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h3><p>这段事件在做一个在线教育项目，有一个检测学生在线是否偷懒的功能。因为网站和后台的交互比较多所以就记录用户最新发送ajax请求的时间，再用计时器不断轮询这个时间看是否大于规定时间来判断孩子是否偷懒。</p>
<h3 id="2、难点"><a href="#2、难点" class="headerlink" title="2、难点"></a>2、难点</h3><p>1、要是这个时间记录在后台那么我们就要不断到后台请求这个时间这肯定是不合理的。<br>2、要在浏览器端实现多页面间的数据共享。<br>3、实现多个页面之间的计时器同步（假如两个页面的计时器差3s,那么这两个页面检测偷懒提示就会差3s）。<br>4、一个页面的提示关闭，所有页面的提示都要关闭。</p>
<h3 id="3、解决方法"><a href="#3、解决方法" class="headerlink" title="3、解决方法"></a>3、解决方法</h3><p>1、使用localStorage实现浏览器端的数据存储，减少服务器压力。<br>2、localStorage实现数据共享。<br>3、用storage事件检测不同页面间的localStorage数据变化，实现不同页面间的计时器同步<br>4、重写localStorage.setItem方法，实现单页面检测localStorage数据变化，实现计时器同步。<br>5、利用Storage间接监听提示关闭事件。</p>
<h3 id="4、代码"><a href="#4、代码" class="headerlink" title="4、代码"></a>4、代码</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">on</span> <span class="keyword">the</span> way</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[函数节流]]></title>
      <url>/blog/2017/07/12/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>DOM操作比起非DOM操作需要更多的内存和cpu时间，连续事件内进行多次的DOM操作可能会导致浏览器挂起或崩溃。例如resize,mousemove,scroll,keydown,keyup（打字时）等事件。这时便可以使用函数节流来介绍DOM操作，此篇主要介绍了函数节流的思想和方法。<a id="more"></a></p>
<h2 id="一、函数节流思想原理"><a href="#一、函数节流思想原理" class="headerlink" title="一、函数节流思想原理"></a>一、函数节流思想原理</h2><h3 id="1、思想"><a href="#1、思想" class="headerlink" title="1、思想"></a>1、思想</h3><p>函数节流的基本思想是，某些操作不能在没有间断的情况下连续重复执行。</p>
<h3 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h3><p>第一次调用时创建一个一次性定时器，在指定延迟时间后执行代码。第二次调用时，清空这个定时器重新创建一个新的计时器。如果前一个计时器执行完毕，没有什么关系，但是如果前一个计时器尚未执行，那个就会用新的计时器代替，时间从零开始。</p>
<h3 id="3、方法"><a href="#3、方法" class="headerlink" title="3、方法"></a>3、方法</h3><p>在《javascript高级程序设计》一书中有专门关于函数节流的介绍，下面是它的几个方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> processor=&#123;</div><div class="line">	<span class="attr">timeoutId</span>:<span class="literal">null</span>,</div><div class="line">	<span class="comment">//实际的操作</span></div><div class="line">	method:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="number">666</span>);</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//需要进行的初始化操作</span></div><div class="line">	process:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		clearTimeout(<span class="keyword">this</span>.timeoutId);</div><div class="line">		<span class="keyword">var</span> that=<span class="keyword">this</span>;</div><div class="line">		<span class="keyword">this</span>.timeoutId=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			that.method();</div><div class="line">		&#125;,<span class="number">100</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用</span></div><div class="line"><span class="built_in">window</span>.onresize=processor.process();</div></pre></td></tr></table></figure></p>
<p>这个把实际操作的方法和函数节流方法封装成一个对象，看起来麻烦一点。在计时器中函数的执行环境是window，这里用that储存执行环境。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(</span><span class="function"><span class="keyword">method</span>,<span class="title">time</span>,<span class="title">context</span>)&#123;</span></div><div class="line">	clearTimeout(<span class="function"><span class="keyword">method</span>.<span class="title">timeoutId</span>);</span></div><div class="line">	<span class="function"><span class="keyword">method</span>.<span class="title">timeoutId</span>=</span>setTimeout(<span class="function"><span class="keyword">function</span>(</span>)&#123;</div><div class="line">		<span class="function"><span class="keyword">method</span>.<span class="title">call</span>(</span>context);</div><div class="line">	&#125;,time);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">haha</span>(</span>)&#123;</div><div class="line">	console.<span class="built_in">log</span>(<span class="number">666</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用</div><div class="line">window.onresize=<span class="function"><span class="keyword">function</span>(</span>)&#123;</div><div class="line">	throttle(haha,<span class="number">100</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个也是用的计时器和上面的原理相同只是做了简化，把timeoutId作为函数的变量储存。三个参数分别是：{method:要执行的操作,time:在多长时间内不能重复执行，context:执行环境}，省略第三个参数在全局执行。</p>
<h3 id="4、升级版"><a href="#4、升级版" class="headerlink" title="4、升级版"></a>4、升级版</h3><p>这些方法也是有不足之处的，例如你想页面滚动加载，那你一直滚动就会重复更新计时器，那页面加载事件岂不是执行不了吗。随意在网上看到一个升级版节流函数，觉得很好就mark一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method,time,mustRunTime</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> time=<span class="literal">null</span>;</div><div class="line">	<span class="keyword">var</span> t_start;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> context=<span class="keyword">this</span>,args=<span class="built_in">arguments</span>,t_curr=+<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">		clearTimeout(thimer);</div><div class="line">		<span class="comment">//第一次执行</span></div><div class="line">		<span class="keyword">if</span>(!t_start)&#123;</div><div class="line">			t_start=t_curr;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(t_curr-t_start&gt;=mustRunTime)&#123;</div><div class="line">			<span class="comment">//时间超过最大限制时间，执行一次</span></div><div class="line">			method.apply(context,args);</div><div class="line">			t_start=t_curr;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			timer=setTimeout(funciton()&#123;</div><div class="line">				method.apply(context,args);</div><div class="line">			&#125;,time);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">haha</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">666</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用</span></div><div class="line"><span class="built_in">window</span>.onresize=throttle(haha,<span class="number">60</span>,<span class="number">100</span>);</div></pre></td></tr></table></figure></p>
<p><code>throttle(haha,60,100)</code>意思是60ms内重复操作不执行，超过100ms必须执行一次。这个方法加入了一个最大时间判断，在进行优化程序的同时尽量解决用户体验。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[一元运算符]]></title>
      <url>/blog/2017/07/07/%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>最近看到一个+new Date()的语法方式，就顺便研究了一下一元运算符，此篇主要介绍了一元运算符。<a id="more"></a></p>
<h2 id="一、-运算符"><a href="#一、-运算符" class="headerlink" title="一、+-运算符"></a>一、+-运算符</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、+"></a>1、+</h3><p>那就从+new Date()语法开始，其实这里并没有什么高级语法，只是+会把后面的内容变为number类型（对数字无效）。这里的<code>+new Date()=Number(new Date())</code>。<code>console.log(typeof(+new Date()));</code>得到number类型。<br>这里比较奇怪的是new Date()对象竟然可以成功转为number类型，以后再也不用get.time()方法了。</p>
<h3 id="2、"><a href="#2、" class="headerlink" title="2、-"></a>2、-</h3><p>减法跟加法一致，都是把后面的内容变为数字，只不过还会对该值求负。和上面一样如果转不了就返回NaN也符合Number()的特征。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sNum = <span class="string">"20"</span>;</div><div class="line">alert(<span class="keyword">typeof</span> sNum);	<span class="comment">//输出 "string"</span></div><div class="line"><span class="keyword">var</span> iNum = -sNum;</div><div class="line">alert(iNum);		<span class="comment">//输出 "-20"</span></div><div class="line">alert(<span class="keyword">typeof</span> iNum);	<span class="comment">//输出 "number"</span></div></pre></td></tr></table></figure></p>
<h2 id="二、-a和a"><a href="#二、-a和a" class="headerlink" title="二、++a和a++"></a>二、++a和a++</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(++a);<span class="comment">//输出4</span></div><div class="line"><span class="keyword">var</span> b=<span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(b++);<span class="comment">//输出3</span></div></pre></td></tr></table></figure>
<p>这个就是“先执行再运算”和“先运算再执行”，其实也好记，加号在前边就是先加自己在管其他。</p>
<h2 id="三、void、delete"><a href="#三、void、delete" class="headerlink" title="三、void、delete"></a>三、void、delete</h2><h3 id="1、delete"><a href="#1、delete" class="headerlink" title="1、delete"></a>1、delete</h3><p>delete运算符可以将自定义的属性和方法删除：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</div><div class="line">o.name = <span class="string">"David"</span>;</div><div class="line">alert(o.name);	<span class="comment">//输出 "David"</span></div><div class="line"><span class="keyword">delete</span> o.name;</div><div class="line">alert(o.name);	<span class="comment">//输出 "undefined"</span></div></pre></td></tr></table></figure></p>
<p>此运算符在发生原型遮蔽时删除属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Person.prototype.name=<span class="string">"Lee"</span>;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</div><div class="line">person1.name=<span class="string">"James"</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//James</span></div><div class="line"><span class="comment">//这里不论是怎样赋值name(null或"")都只会在person1这个实例中修改，</span></div><div class="line"><span class="comment">//原型的方法还是会被遮蔽。这时delete方法的作用就体现出来了。</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person1.name;</div><div class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//Lee</span></div></pre></td></tr></table></figure></p>
<p>同时我们也发现，对于Javascript内置的属性和方法是不行的:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> o.<span class="built_in">toString</span>;//报错</div></pre></td></tr></table></figure></p>
<p>toString()是JavaScript原生方法。</p>
<h3 id="2、void"><a href="#2、void" class="headerlink" title="2、void"></a>2、void</h3><p>void 运算符对任何值返回 undefined。该运算符通常用于避免输出不应该输出的值。例如<code>&lt;a href=&quot;javascript:void(back())&quot;&gt;</code>这里点击a即执行了back事件，有避免了页面跳转。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[console打印dom对象]]></title>
      <url>/blog/2017/07/07/console%E6%89%93%E5%8D%B0dom%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>在操作dom时，可能会需要在控制台查看Dom对象的属性方法（比差文档快多了），本篇就介绍了这样的方法<a id="more"></a></p>
<h2 id="一、原生和jqDom对象console对比"><a href="#一、原生和jqDom对象console对比" class="headerlink" title="一、原生和jqDom对象console对比"></a>一、原生和jqDom对象console对比</h2><p>我们想要获得原生Dom的属性方法，像这样：<br><img src="/blog/myimages/consoleDom/p1.png" alt="打印的Dom详细"><br>这里可以看到一切。我们知道jquery是很好在控制台输出的，只要有$(“”)选择器查找到元素console一下就会得到：<br><img src="/blog/myimages/consoleDom/p2.png" alt="打印的jqDom"><br>0的位置是htmlDom,但是下面的方法就是jq的方法了。很简单可以自己试一下。<br>但是正题来了怎样才能在控制台console原生Dom对象呢？</p>
<h2 id="二、在控制台输出原生对象的方法"><a href="#二、在控制台输出原生对象的方法" class="headerlink" title="二、在控制台输出原生对象的方法"></a>二、在控制台输出原生对象的方法</h2><pre><code>&lt;div id=&quot;d1&quot;&gt;&lt;div id=&quot;d2&quot;&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;

var d1=document.getElementById(&quot;d1&quot;);
var d2=document.getElementById(&quot;d2&quot;);

console.log(d1.childNodes); //Dom 对象
console.log(d1.firstChild); //文本
console.log(d1.lastChild);  //文本
console.log(d2.parentNode); //文本
console.log(d2.nextSibling);//文本
</code></pre><p>不要怀疑上面的都是对象(不信typeof一下)，只是浏览器的控制台输出策略不同。<br>测试结果：用选择器选的只能输出文本，只有一个childNodes可以输出对象。这是chrome浏览器，但是火狐就比较厉害了无论用什么找到的都能输出对象。当然你也不可能在专门为了看属性在打开一个火狐浏览器（用火狐开发的当没看到）。下面就介绍chrome的输出对象的方法：<br>当当当，就是全部<strong>封装成Array</strong>的形式。 <code>console.log([d1.lastChild])</code>这样你就可以得到输出的dom对象了还可以得到Array的方法属性奥，似不似很厉害啊。<br><img src="/blog/myimages/consoleDom/p4.png" alt="打印的jqDom">  </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[console.log一个奇怪的问题]]></title>
      <url>/blog/2017/07/01/console/</url>
      <content type="html"><![CDATA[<p>最近遇到一个关于console.log奇怪的问题，搞得我是百思不得其解，写出来做一下记录:<br><a id="more"></a><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a=&#123;<span class="built_in">name</span>:<span class="number">1</span>&#125;;</div><div class="line">console.<span class="built_in">log</span>(a);</div><div class="line">a.<span class="built_in">name</span>=<span class="number">2</span>;</div><div class="line">console.<span class="built_in">log</span>(a);</div></pre></td></tr></table></figure></p>
<p>结果显而易见是name:1;name:2啊，但打开控制台，呵呵：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span> </div><div class="line">	name: <span class="string">"2"</span></div><div class="line">	__proto__: <span class="built_in">Object</span></div><div class="line"><span class="built_in">Object</span></div><div class="line">	name: <span class="string">"2"</span></div><div class="line">	__proto__: <span class="built_in">Object</span></div></pre></td></tr></table></figure></p>
<p>完了感觉自己白学js了，当我抱着怀疑人生的态度刷新了一遍浏览器之后，终于见到我想见的答案了：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span> </div><div class="line">	name: <span class="string">"1"</span></div><div class="line">	__proto__: <span class="built_in">Object</span></div><div class="line"><span class="built_in">Object</span></div><div class="line">	name: <span class="string">"2"</span></div><div class="line">	__proto__: <span class="built_in">Object</span></div></pre></td></tr></table></figure>
<p>之所以会出现这样的结果是因为<strong>代码在运行的时候控制台并没有打开</strong>。<br>console并不是JavaScript的对象，而是浏览器提供的方法，只有当你打开控制台是它才生效，所以当你打开网页代码执行完毕之后,console.log并没有执行，而是等到你打开控制台之后才会执行，这时的a早已经不是原来的单纯的a了。也就是相当于这样的执行顺序：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;<span class="built_in">name</span>: <span class="string">'1'</span>&#125;;</div><div class="line">a.<span class="built_in">name</span> = <span class="string">'2'</span>;</div><div class="line">console.<span class="built_in">log</span>(a);</div><div class="line">console.<span class="built_in">log</span>(a);</div></pre></td></tr></table></figure></p>
<p>而你在打开控制台之后再刷新页面得到的也就是之前正常的顺序了。<br>感觉浏览器厂商这么做也是有一定道理的，既然你console.log了肯定是要打开控制台调试的嘛，你不打开控制台看那我也就不执行多余的console操作了，节省了内存。</p>
<p>最后还有一个问题没有解决：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"page"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="keyword">var</span> a=<span class="built_in">document</span>.getElementById(<span class="string">"page"</span>);</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"span"</span>));</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line">得到结果：</div><div class="line">&lt;div id=<span class="string">"page"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&lt;div id=<span class="string">"page"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>放心js是顺序执行的，但是无论我怎么刷新页面结果都是一样的，这就尴尬了。等待之后有机会在探讨吧，有哪位大神指导一下是最好的啦。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Pagination分页增加页面跳转功能]]></title>
      <url>/blog/2017/05/26/pagination/</url>
      <content type="html"><![CDATA[<p>Pagination是JQuery一款十分经典的分页插件，我在之前的基础上做了一点很小的改动：1、增加了页码输入跳转的功能，可以自己决定是否出现此功能。2、增加一个点击事件函数，返回点击的页码，可以实现ajax分次请求<a id="more"></a>  </p>
<p><a href="http://oljtqy7i8.bkt.clouddn.com/pagination.zip" title="js和css源码" target="_blank" rel="external">Pagination源码下载</a></p>
<h2 id="一、pagination使用方法"><a href="#一、pagination使用方法" class="headerlink" title="一、pagination使用方法"></a>一、pagination使用方法</h2><h3 id="1、使用方法"><a href="#1、使用方法" class="headerlink" title="1、使用方法"></a>1、使用方法</h3><p>跟一般的jQuery插件一样，此插件需要引入jq,使用也很简单便捷。方法是pagination，例如<code>$(&quot;#page&quot;).pagination(100);</code>，这里的100参数是必须的，表示显示项目的总个数，这是最简单的使用，得到的显示如下：<br><img src="/blog/myimages/pagination/p1.png" alt="展示效果"></p>
<h3 id="2、参数详解"><a href="#2、参数详解" class="headerlink" title="2、参数详解"></a>2、参数详解</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">这是参数的默认值，可以自行修改</div><div class="line">&#123;</div><div class="line"><span class="symbol">    items_per_page:</span><span class="number">10</span>,<span class="comment">//每页数目</span></div><div class="line"><span class="symbol">    num_display_entries:</span><span class="number">10</span>,<span class="comment">//中间数目</span></div><div class="line"><span class="symbol">    current_page:</span><span class="number">0</span>,<span class="comment">//当前页数</span></div><div class="line"><span class="symbol">    num_edge_entries:</span><span class="number">0</span>,<span class="comment">//边缘数目</span></div><div class="line"><span class="symbol">    link_to:</span><span class="string">"#"</span>,</div><div class="line"><span class="symbol">    prev_text:</span><span class="string">"Prev"</span>,</div><div class="line"><span class="symbol">    next_text:</span><span class="string">"Next"</span>,</div><div class="line"><span class="symbol">    ellipse_text:</span><span class="string">"..."</span>,<span class="comment">//中间多想代替文字</span></div><div class="line"><span class="symbol">    prev_show_always:</span>true,<span class="comment">//上一页是否展示</span></div><div class="line"><span class="symbol">    next_show_always:</span>true,<span class="comment">//下一个页是否展示</span></div><div class="line"><span class="symbol">    ifGo:</span>false,<span class="comment">//决定是否出现跳转功能</span></div><div class="line"><span class="symbol">    ifGo_text:</span><span class="string">"Go"</span>,<span class="comment">//跳转到文字</span></div><div class="line"><span class="symbol">    a_fn:</span>function()&#123;return false;&#125;,<span class="comment">//每次单击的触发的事件（返回页码，可以ajax请求）</span></div><div class="line"><span class="symbol">    callback:</span>function()&#123;return false;&#125;<span class="comment">//每次单击的回调函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、使用举例"><a href="#3、使用举例" class="headerlink" title="3、使用举例"></a>3、使用举例</h3><h4 id="1、原版"><a href="#1、原版" class="headerlink" title="1、原版"></a>1、原版</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"page"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"pagination"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">$(<span class="string">"#Pagination"</span>).pagination(<span class="number">56</span>, &#123;</div><div class="line">    <span class="attr">num_edge_entries</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">num_display_entries</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">callback</span>: pageselectCallback,</div><div class="line">    <span class="attr">items_per_page</span>:<span class="number">1</span>，</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>效果：<br><img src="/blog/myimages/pagination/p2.png" alt="展示效果"><br>这段代码表示的含义是：总共有56(maxentries)个列表项，首尾两侧分页显示2(num_edge_entries)个，连续分页主体数目显示4(num_display_entries)个，回调函数为pageselectCallback(callback)，每页显示的列表项为1(items_per_page)。您可以对照参数表修改配置这里的参数。</p>
<h4 id="2、页码输入跳转版"><a href="#2、页码输入跳转版" class="headerlink" title="2、页码输入跳转版"></a>2、页码输入跳转版</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;div id="page" class="pagination"&gt;</span><span class="params">&lt;/div&gt;</span></div><div class="line">$(<span class="string">"#Pagination"</span>).pagination(<span class="number">56</span>, &#123;</div><div class="line"><span class="symbol">    num_edge_entries:</span> <span class="number">2</span>,</div><div class="line"><span class="symbol">    num_display_entries:</span> <span class="number">4</span>,</div><div class="line"><span class="symbol">    callback:</span> pageselectCallback,</div><div class="line"><span class="symbol">    items_per_page:</span><span class="number">1</span>，</div><div class="line"><span class="symbol">    ifGo:</span><span class="number">10</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>效果：<br><img src="/blog/myimages/pagination/p3.png" alt="展示效果"><br>这段代码相对于上面多了一个ifGo：10，含义是只要分页超过10页就会出现输入跳转功能，可以点击Go和键盘enter跳转，默认是不显示。</p>
<h4 id="3、实现ajax分页请求"><a href="#3、实现ajax分页请求" class="headerlink" title="3、实现ajax分页请求"></a>3、实现ajax分页请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"page"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"pagination"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">$(<span class="string">"#Pagination"</span>).pagination(<span class="number">56</span>, &#123;</div><div class="line">    <span class="attr">num_edge_entries</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">num_display_entries</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">a_fn</span>: getpage,</div><div class="line">    <span class="attr">callback</span>: pageselectCallback,</div><div class="line">    <span class="attr">items_per_page</span>:<span class="number">1</span>，</div><div class="line">    ifGo:<span class="number">10</span></div><div class="line">&#125;);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getpage</span>(<span class="params">page_index</span>)</span>&#123;</div><div class="line">    <span class="comment">//这里可以发送ajax请求，请求点击页的数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意点：这里a_fn不能和获取56的函数共用一个，函数内容相同的情况也不能（要重写一个不包括pagination初始化的）。如果共用一个就会每次分页切换时都要重新加载一遍pagination造成浪费。当然新加一个全局变量保证在切换页码时不再加载pagination限制一下也是可以的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">if</span>First=<span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">if</span>First)&#123;</div><div class="line">    $(<span class="string">"#Pagination"</span>.pagination(56));</div><div class="line">    <span class="keyword">if</span>First=<span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="二、paginationJS跳转功能实现"><a href="#二、paginationJS跳转功能实现" class="headerlink" title="二、paginationJS跳转功能实现"></a>二、paginationJS跳转功能实现</h2><h3 id="1、获取用户输入数字方法"><a href="#1、获取用户输入数字方法" class="headerlink" title="1、获取用户输入数字方法"></a>1、获取用户输入数字方法</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function goNum()&#123;</div><div class="line">            <span class="keyword">var</span> np = numPages();</div><div class="line">            <span class="keyword">var</span> <span class="built_in">num</span>=Number(jQuery(<span class="string">".input_num"</span>).val());</div><div class="line">            <span class="comment">//判断用户输入有效值，并且不是当前页</span></div><div class="line">            <span class="keyword">if</span>(<span class="built_in">num</span>&amp;&amp;current_page!=<span class="built_in">num</span><span class="number">-1</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="built_in">num</span>&gt;=np)&#123;</div><div class="line">                    page_id=np<span class="number">-1</span>;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">num</span>&lt;=<span class="number">1</span>)&#123;</div><div class="line">                    page_id=<span class="number">0</span>;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    page_id=<span class="built_in">num</span><span class="number">-1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//取得输入的数字调用pageSelected;</span></div><div class="line">                pageSelected(page_id,<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>此方法用来获取用户输入的数字，并对数字有效性进行判断。若输入的数字大于最大分页数则跳转最后一页;若小于1则跳转到第一页;若不是number则不作反应。</p>
<h3 id="2、绑定键盘事件函数"><a href="#2、绑定键盘事件函数" class="headerlink" title="2、绑定键盘事件函数"></a>2、绑定键盘事件函数</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">keybind</span><span class="params">(e)</span></span>&#123;</div><div class="line">            <span class="keyword">var</span> code=e.keyCode;</div><div class="line">            <span class="keyword">if</span>(code==(<span class="number">13</span>||<span class="number">108</span>))&#123;</div><div class="line">                goNum();</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h3 id="3、判断是否添加跳转功能"><a href="#3、判断是否添加跳转功能" class="headerlink" title="3、判断是否添加跳转功能"></a>3、判断是否添加跳转功能</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*新加，判断是否添加go按钮*/</span></div><div class="line"><span class="keyword">if</span>(opts.ifGo&amp;&amp;<span class="built_in">np</span>&gt;=opts.ifGo)&#123;</div><div class="line">    <span class="built_in">var</span> inp=jQuery(<span class="string">"&lt;input class='input_num' type='text'/&gt;"</span>).bind(<span class="string">"keydown"</span>,keybind);</div><div class="line">    <span class="built_in">var</span> <span class="built_in">go</span>=jQuery(<span class="string">"&lt;span class='go'&gt;"</span>+opts.ifGo_text+<span class="string">"&lt;/span&gt;"</span>).bind(<span class="string">"click"</span>,goNum);</div><div class="line">    panel.<span class="built_in">append</span>(inp,<span class="built_in">go</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在drawlink主函数中添加判断是否绘制跳转按钮，条件是分页总数必须大于你设定的ifGo的值。若大于则创建input和go并绑定相应事件。</p>
<h3 id="4、css修改"><a href="#4、css修改" class="headerlink" title="4、css修改"></a>4、css修改</h3><p>下载资源中包括了css文件，你可以随心所欲修改你的css样式。  </p>
<h2 id="三、知识点"><a href="#三、知识点" class="headerlink" title="三、知识点"></a>三、知识点</h2><h3 id="1、js是值传递但是基本类型和引用类型表现不同。"><a href="#1、js是值传递但是基本类型和引用类型表现不同。" class="headerlink" title="1、js是值传递但是基本类型和引用类型表现不同。"></a>1、<strong>js是值传递但是基本类型和引用类型表现不同。</strong></h3><p>来上代码：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a=<span class="keyword">b=&#123;page:1&#125;;</span></div><div class="line"><span class="keyword">b.page=3;</span></div><div class="line">console.log(a)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>结果是page:3。上边a、b、包括后面的对象的地址都是指向堆中的同一个obj，所以b改变了a相应也会改变，同理上面的pannel和jq对象的引用相同panner改变this也会跟着改变。<br>强化理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    obj.name=<span class="string">"小明"</span>;</div><div class="line">    obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name=<span class="string">"小刚"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line"><span class="built_in">console</span>.log(person.name)</div></pre></td></tr></table></figure></p>
<p>结果：小明。首先创建一个person对象，person的地址就指向堆中一个object，调用setName是复制了person的地址给了obj，现在他们俩共同指向同一个object，于是改了obj的就相当于改了person的;接下来这个obj始乱终弃有指向了新的object2，也就和person再无任何瓜葛，他自己怎么玩是他自己的事情。所以最终结果是小明。  </p>
<h3 id="2、注：dom元素和jq对象都是对象。"><a href="#2、注：dom元素和jq对象都是对象。" class="headerlink" title="2、注：dom元素和jq对象都是对象。"></a>2、注：dom元素和jq对象都是对象。</h3><p>$(“div”):这个类似于一个构造函数，把dom元素封装起来并添加相应jq的方法。dom元素可以直接影响这个新对象，但是这个对象不能影响dom元素（针对这个对象的操作，例如添加name方法）。<br><code>document.getElementById()</code>之类的：这是个选择器，他直接指向dom元素，dom和它相互影响。</p>
<p>typeof用于检测简单类型(具体说他是确定一个变量是字符串、数值、布尔值、还是undefined的最佳工具，注：null返回object),返回一个字符串。  </p>
<p>对于对象，我们更想知道的是什么类型的对象。所以引进了instanceof操作符。  </p>
<p>person instanceof Object 这样来检测person是不是Object。  </p>
<p>person instanceof Array 这样来检测person是不是Array。  </p>
<h3 id="3、关于回调函数。"><a href="#3、关于回调函数。" class="headerlink" title="3、关于回调函数。"></a>3、关于回调函数。</h3><p>回调函数的意思就是在函数执行完毕调用的函数，而在这里使用参数的形式来设置回调函数，灵活性搞，可以任意设置回调函数。<br>pagination的回调函数的作用是显示对应分页的列表项内容,回调函数在用户每次点击分页链接的时候执行。<br>注意点：这里pagination的回调函数在分页创建时就调用了一次。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JQ的四种绑定方式]]></title>
      <url>/blog/2017/04/28/jq%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="一、bind-unbind方法"><a href="#一、bind-unbind方法" class="headerlink" title="一、bind unbind方法"></a>一、bind unbind方法</h2><p>bind的特点就是会把监听器绑定到目标元素上，有几个事件就绑定几个，它和<code>$(selector).click(function)</code>是一样的。既然是绑定在目标元素上，也就是这个目标元素在绑定此事件的js执行完时，必须存在于页面上，此事件绑定才算成功。而之后页面动态添加的元素则不会绑定这个事件。<a id="more"></a><br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(selector).<span class="keyword">bind</span>(event,<span class="keyword">data</span>,<span class="function"><span class="keyword">function</span></span>)</div></pre></td></tr></table></figure></p>
<h2 id="二、live-die方法"><a href="#二、live-die方法" class="headerlink" title="二、live die方法"></a>二、live die方法</h2><p>live方法利用了事件代理的方法把监听器绑定到document，这样就即使是动态添加的事件也不需要重新绑定了。但是这个还是有一定问题的，他把事件监听放在document上，目标事件要层层冒泡才能触发，这显然是是影响性能浪费时间，不建议使用此方法。jQuery官方已宣布在1.7版本开始废弃，1.9版本移除live方法。那么事件委托就交给delegate。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(selector).live(event,<span class="keyword">data</span>,<span class="function"><span class="keyword">function</span></span>)</div></pre></td></tr></table></figure></p>
<h2 id="三、delegate-undelegate方法"><a href="#三、delegate-undelegate方法" class="headerlink" title="三、delegate undelegate方法"></a>三、delegate undelegate方法</h2><p>delegate方法是live方法的改进版。于bind方法不同，delegate方法显然就聪明多了，它可以让你自由的选择绑定监听的元素，我们可以选择里目标元素最近的父元素上，能让事件快速的冒泡上去，在第一时间处理。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(parentSelector).delegate(selector,event,<span class="keyword">data</span>,<span class="function"><span class="keyword">function</span></span>)</div></pre></td></tr></table></figure></p>
<h2 id="四、on-off方法"><a href="#四、on-off方法" class="headerlink" title="四、on off方法"></a>四、on off方法</h2><p>自 jQuery 版本 1.7 起，on() 方法是 bind()、live() 和 delegate()方法的代替品，用它可以代替bind,live,delegate方法，简化了书写。<code>$(selector).on(event,function)</code>代替bind方法。<br>官方推荐尽量使用on方法，其他这几个方法都是内部调用on方法的，直接使用on方法可以提高效率，所以我们可以用on方法代替其他几个方法。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(parentSelector).on(event,selector,<span class="keyword">data</span>,<span class="function"><span class="keyword">function</span></span>,map)</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[写在前面的话]]></title>
      <url>/blog/2017/04/26/hexo-GitHub-Pages-Dropbox-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>从今天开始我的个人博客总算是初具模型了，虽然很简陋但也算是自己小窝了。对于建立自己个人博客，自己很久之前就是有这个想法的，但中间各种事(自己的拖延症的借口)，加上自己水平有限，就一拖再拖了。<br>临近毕业，正好赶上要作毕业设计，就突发奇想看看能不能做一个博客交差呢？即使不行，还可以督促自己完成构建个人博客，怎么算都是赚的。<a id="more"></a>于是就有了这个博客的雏形，还有感谢这个主题的创建者还有网上超牛的博主，他们的无私分享让我受益无穷(生活在当今世界真是幸运）。<br>当然这只是个初级版本，今后还会努力建设自己的小窝的。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
