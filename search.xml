<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[webpack总结1]]></title>
      <url>/blog/2017/09/26/webpack%E6%80%BB%E7%BB%931/</url>
      <content type="html"><![CDATA[<p>前前后后学习webpack快两个周了，算是入门了，此篇文章主要是对学习内容的总结，同时记录下心得体会<a id="more"></a></p>
<h3 id="一、webpack的主要工作"><a href="#一、webpack的主要工作" class="headerlink" title="一、webpack的主要工作"></a>一、webpack的主要工作</h3><p>1、把你整个项目当做一个整体，通过给定一个入或者多个入口，webpack将从这个文件开始找到你所有依赖，使用loaders，plugins处理他们（解析，编译，优化），最后打包成一个或者多个浏览器可以识别的JavaScript文件。<br>2、同时webpack也提供一些简单的开发工具（devtool）来简化我们的开发过程。</p>
<h3 id="二、webpack基本介绍"><a href="#二、webpack基本介绍" class="headerlink" title="二、webpack基本介绍"></a>二、webpack基本介绍</h3><p><strong>注：所有代码都是在window环境下，webpack版本3.6.0，node版本6.11.3，构建react项目。</strong></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>npm init</code>初始化npm一路回车即可或者使用<code>npm init -y</code>跳过。<br>此命令表示初始化npm，处于npm管理之下。package.json文件用来配置当前包，<a href="http://zoucz.com/blog/2016/02/17/npm-package/" target="_blank" rel="external">package.json属性详解</a>。</p>
<p>在你项目所在目录下执行此命令安装最新版本或特定版本：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> webpack <span class="comment">--save-dev</span></div><div class="line">npm <span class="keyword">install</span> webpack@&lt;<span class="keyword">version</span>&gt; <span class="comment">--save-dev</span></div></pre></td></tr></table></figure></p>
<h4 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h4><p>在package.json的scripts中添加<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">"build":</span> <span class="comment">"webpack</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">progress</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">colors</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">display</span><span class="literal">-</span><span class="comment">error</span><span class="literal">-</span><span class="comment">details</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">config</span> <span class="comment">webpack</span><span class="string">.</span><span class="comment">prod</span><span class="string">.</span><span class="comment">js"</span><span class="string">,</span></div><div class="line"><span class="comment">"start":</span> <span class="comment">"webpack</span><span class="literal">-</span><span class="comment">dev</span><span class="literal">-</span><span class="comment">server</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">open</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">config</span> <span class="comment">webpack</span><span class="string">.</span><span class="comment">dev</span><span class="string">.</span><span class="comment">js"</span><span class="string">,</span></div></pre></td></tr></table></figure></p>
<p>进行这样配置之后就不用每次都在命令行输入一长串的参数了，只要输入<code>npm run {script name}</code>即可。<br><code>npm run build</code>执行打包操作,几个常用配置参数，<a href="https://doc.webpack-china.org/api/cli/#resolve-" target="_blank" rel="external">详细信息找官网</a>。</p>
<ul>
<li><code>--progress</code>：显示打包进度。</li>
<li><code>--colors</code>：开启控制台颜色。</li>
<li><code>--display-error-details</code>：显示详细的错误信息。</li>
<li><code>--config webpack.prod.js</code>：把默认配置文件（webpack.config.js）改为webpack.prod.js。</li>
</ul>
<blockquote>
<p>package.json中的script会按照一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写详细的路径。</p>
</blockquote>
<h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><h5 id="1、entry"><a href="#1、entry" class="headerlink" title="1、entry"></a>1、entry</h5><p><strong>概述</strong>：entry告诉 webpack 从哪里开始，并根据依赖关系图确定需要打包的内容。webpack会从它开始打包所有依赖（引用）。<br><strong>entry接受三种形式</strong>： string | object | array</p>
<ul>
<li><code>entry:&#39;./src/index1&#39;</code>表示单一模块作为起点，通过index1可以找到所有的依赖，例如单页面应用。</li>
<li><code>entry: [&quot;./src/index1&quot;, &quot;./src/index2&quot;]</code>表示index1，index2并没有任何的依赖关系（他们之间没有相互引用），但是还需要把它们打包到一起，可以通过把它们放在同一entry中实现。</li>
<li>对象：把index1和index2打包成两个，每一个都会有一个[name]属性，对应entry中的属性名。这个要和output配合。<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">entry</span>:&#123;</div><div class="line">	<span class="attribute">index1</span>:<span class="string">"./src/index1"</span>,</div><div class="line">	<span class="attribute">index2</span>:<span class="string">'./src/index2'</span></div><div class="line">&#125;,</div><div class="line"><span class="attribute">output</span>:&#123;</div><div class="line">	<span class="attribute">path</span>:<span class="string">'./build'</span>,</div><div class="line">	<span class="attribute">filename</span>:<span class="string">'js/[name].js'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>路径解释</strong>：</p>
<ul>
<li><code>./</code>  表示当前路径</li>
<li><code>../</code> 表示上一级目录</li>
<li><code>/</code>   表示绝对路径</li>
<li><code>context</code>  指定根目录，默认是脚本执行环境</li>
</ul>
<h5 id="2、output"><a href="#2、output" class="headerlink" title="2、output"></a>2、output</h5><p><strong>概述</strong>：output告诉webpack如何处理打包后的代码。<br><strong>参数解释</strong>：</p>
<ul>
<li><code>path</code>：打包后文件存放路径。</li>
<li><code>filename</code>：打包后文件名称或者（路径+名称）。</li>
<li><code>chunkFilename</code>：此选项决定了非入口(non-entry) chunk 文件的名称，我的理解是未被列在entry中，却又需要被打包出来的文件命名配置，例如给按需加载的模块命名。</li>
<li><code>publicPath</code>:对于按需加载(on-demand-load)或加载外部资源(external resources)（如图片、文件等）来说，publicPath 是很重要的选项。可以理解为占位符，例如可以设置上线时设置CDN，所有文件路径都会加上publicPath设置的路径。</li>
<li><code>[chunkhash]</code>和<code>[hash]</code>会在下面缓存中详细说明。</li>
</ul>
<p><strong>简单的webpack.config.js文件配置</strong>：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const <span class="built_in">path</span> = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">  entry: <span class="string">'./src/index1.js'</span>,</div><div class="line">  <span class="built_in">output</span>: &#123;</div><div class="line">    <span class="built_in">path</span>: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'build'</span>),</div><div class="line">    filename: <span class="string">'main.bundle.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>执行打包命令(<code>npm run build</code>)就会把所有index1.js的依赖打包到build目录下的main.bundle.js中。</p>
<h3 id="三、loader"><a href="#三、loader" class="headerlink" title="三、loader"></a>三、loader</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>loader 用于对模块的源代码进行转换。loader 可以使你在加载（import）模块时预处理文件。通过使用不同的loader可以实现对不同格式文件的处理，例如把less转换为css，es6转换为浏览器兼容的js文件，对react把jsx语法转换为js文件，甚至允许你直接在js中<code>import</code>css文件。总的来说loaders就是在打包构建过程中用来处理源文件（JSX，Scss，Less..）的。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>版本间会略有差别，请按照官网方法。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">module</span>: &#123;</div><div class="line">    <span class="attribute">rules</span>: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css$/,</div><div class="line">        exclude:path.<span class="built_in">resolve</span>(__dirname, <span class="string">'build'</span>),</div><div class="line">        include:path.<span class="built_in">resolve</span>(__dirname, <span class="string">'src'</span>),</div><div class="line">        use: [</div><div class="line">          &#123; loader: <span class="string">'style-loader'</span> &#125;,</div><div class="line">          &#123;</div><div class="line">            <span class="attribute">loader</span>: <span class="string">'css-loader'</span>,</div><div class="line">            options: &#123;</div><div class="line">              minimize:true//压缩css</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>rules</code>：允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。</li>
<li><code>test</code>：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）。</li>
<li><code>include/exclude</code>：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）。</li>
<li><code>use</code>：使用loader的名称。</li>
<li><code>option</code>：为loader提供额外的设置选项（可选）。</li>
</ul>
<p>这里设置了一个解析css文件的loader，排除了node_modules文件指定，处理src文件提高处理速度。</p>
<h4 id="常见loader"><a href="#常见loader" class="headerlink" title="常见loader"></a>常见loader</h4><h5 id="1、解析css"><a href="#1、解析css" class="headerlink" title="1、解析css"></a>1、解析css</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attribute">test</span>: /\.css$/,</div><div class="line">  exclude:path.<span class="built_in">resolve</span>(__dirname, <span class="string">'build'</span>),</div><div class="line">  include:path.<span class="built_in">resolve</span>(__dirname, <span class="string">'src'</span>),</div><div class="line">  use:[</div><div class="line">    <span class="string">'style-loader'</span>,</div><div class="line">    <span class="string">'css-loader?importLoaders=1'</span>,</div><div class="line">    <span class="string">'postcss-loader'</span>,</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>style-loader</code>：将style标签插入html中。</li>
<li><code>css-loader</code>：使在js中也能解析css。importLoaders使得css的@import的也能用，不过一般也不这么用。</li>
<li><code>postcss-loader</code>：辅助处理css代码。</li>
</ul>
<p>postcss.config.js配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</div><div class="line">  plugins: [</div><div class="line">    <span class="comment">//自动加前缀插件</span></div><div class="line">    require(<span class="string">'autoprefixer'</span>)(&#123;</div><div class="line">    	broswers:[<span class="string">'last 5 versions'</span>]<span class="comment">//浏览器版本，根据自己需求查找</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>postcss-loader支持很多功能，请<a href="https://www.npmjs.com/package/postcss-loader" target="_blank" rel="external">自行查阅</a>。</p>
<h5 id="2、解析less"><a href="#2、解析less" class="headerlink" title="2、解析less"></a>2、解析less</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attribute">test</span>: /\.less$/,</div><div class="line">  exclude:path.<span class="built_in">resolve</span>(__dirname, <span class="string">'build'</span>),</div><div class="line">  include:path.<span class="built_in">resolve</span>(__dirname, <span class="string">'src'</span>),</div><div class="line">  use:[</div><div class="line">    <span class="string">'style-loader'</span>,</div><div class="line">    <span class="string">'css-loader'</span>,</div><div class="line">    <span class="string">'postcss-loader'</span>,</div><div class="line">    <span class="string">'less-loader'</span></div><div class="line">  ] , </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>less-loader</code>处理less。</li>
</ul>
<blockquote>
<p>使用postcss：放在less-loader后面css-loader前面（从右向左解析）。sass-loader和less-loader基本一致。</p>
</blockquote>
<h5 id="3、解析babel"><a href="#3、解析babel" class="headerlink" title="3、解析babel"></a>3、解析babel</h5><p>Babel其实是一个编译JavaScript的平台，它可以实现：</p>
<ul>
<li>使用下一代的JavaScript代码（ES6，ES7…），即使这些标准目前并未被当前的浏览器完全的支持；</li>
<li>使用基于JavaScript进行了拓展的语言，比如React的JSX；</li>
</ul>
<p>我们先来一次性安装这些依赖包<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install </span>--save-dev <span class="keyword">babel-loader </span><span class="keyword">babel-core </span><span class="keyword">babel-preset-env </span><span class="keyword">babel-preset-react </span><span class="keyword">babel-preset-stage-0</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attribute">test</span>:/\.(js|jsx)$/,</div><div class="line">  //对提高打包速度很有用，这里得用绝对路径</div><div class="line">  exclude:path.<span class="built_in">resolve</span>(__dirname, <span class="string">'build'</span>),</div><div class="line">  include:path.<span class="built_in">resolve</span>(__dirname, <span class="string">'src'</span>),</div><div class="line">  use:<span class="string">'babel-loader'</span>,//需要babel-loader babel-core babel-preset-env三个</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>.babelrc配置<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>,'stage<span class="number">-0</span>','react'],</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>babel-preset-env：Without any configuration options, babel-preset-env behaves exactly the same as babel-preset-latest(or babel-preset-es2015, babel-preset-es2016, and babel-preset-es2017 together).</p>
</blockquote>
<p><strong>配置文件说明</strong><br><img src="/blog/myimages/webpack/presets.png" alt="图片"><br>来自<a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="external">阮一峰老师的博客</a></p>
<p>对于React，还要安装 React 和 React-DOM<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> <span class="comment">--save react react-dom</span></div></pre></td></tr></table></figure></p>
<p>现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。</p>
<h5 id="4、加载图片"><a href="#4、加载图片" class="headerlink" title="4、加载图片"></a>4、加载图片</h5><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  test:/\.(<span class="name">png</span>|jpg|gif|svg)$/i,</div><div class="line">  exclude:PATHS.modules,</div><div class="line">  include:PATHS.src,</div><div class="line">  use:[</div><div class="line">    'url-loader?limit=2048&amp;name=img/[name][hash].[ext]',         </div><div class="line">    'img-loader'</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>img-loader</code>用来压缩图片。</li>
<li><code>url-loader</code>功能类似于 file-loader，但是在文件大小（单位 byte）低于指定的limit时，转换成base64编码。file-loader的参数也是有效的如果你写的话它会交给file-loader处理。</li>
</ul>
<blockquote>
<p><a href="http://www.cnblogs.com/coco1s/p/4375774.html" target="_blank" rel="external">base64和csssprites的介绍</a>。<br>总结：图片重复率不高同时图片比较小的情况下可以使用base64优化页面。</p>
</blockquote>
<p><strong>react jsx语法</strong>img路径的写法<code>&lt;img src={require(&#39;../../img/presets.png&#39;)} alt=&quot;&quot;/&gt;</code>。</p>
<h5 id="5、html-loader"><a href="#5、html-loader" class="headerlink" title="5、html-loader"></a>5、html-loader</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attribute">test</span>:/\.html$/,</div><div class="line">  exclude:PATHS.modules,</div><div class="line">  include:PATHS.src,</div><div class="line">  use:[</div><div class="line">     &#123;</div><div class="line">      loader:<span class="string">'html-loader'</span>,</div><div class="line">      options:&#123;</div><div class="line">        attrs:[<span class="string">'img:src'</span>,<span class="string">'a:href'</span>]</div><div class="line">      &#125;</div><div class="line">     &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>html-loader</code>把html导出为字符串使用。上面的设置意思为img的src,a的href可以写相对路径，html-loader会帮你自动转换。但是模板文件的&lt;%= htmlWebpackPlugin.options.title %&gt;就会失效。</li>
</ul>
<h3 id="四、plugin"><a href="#四、plugin" class="headerlink" title="四、plugin"></a>四、plugin</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务，它并不像loader处理单个源文件。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>想要使用一个插件，首先需要利用npm安装它然后 require() 它（内置插件不需要），然后把它的实例添加到 plugins 数组中。<br><strong>HtmlWebpackPlugin</strong><br>此插件的作用是简化html的创建，你可以按照模板创建一个或者多个（实例化多次这个插件）html页面。<br>npm 安装<code>npm install --save-dev html-webpack-plugin</code><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> webpack=<span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports=&#123;</div><div class="line">  entry:&#123;</div><div class="line">    index1:<span class="string">"./src/index1"</span>,</div><div class="line">    index2:<span class="string">'./src/index2'</span></div><div class="line">  &#125;,</div><div class="line">  output:&#123;</div><div class="line">    path:<span class="string">'./build'</span>,</div><div class="line">    filename:<span class="string">'js/[name].js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="keyword">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.css$/</span>,</div><div class="line">        exclude:path.resolve(__dirname, <span class="string">'build'</span>),</div><div class="line">        include:path.resolve(__dirname, <span class="string">'src'</span>),</div><div class="line">        use: [</div><div class="line">          &#123; loader: <span class="string">'style-loader'</span> &#125;,</div><div class="line">          &#123;</div><div class="line">            loader: <span class="string">'css-loader'</span>,</div><div class="line">            options: &#123;</div><div class="line">              minimize:<span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">      title:<span class="string">'My webpack-test-react'</span>,</div><div class="line">      inject:<span class="string">'body'</span>,</div><div class="line">      filename:<span class="string">'admin.html'</span>,</div><div class="line">      template:<span class="string">'./src/templete/index.html'</span>,<span class="comment">//要使用的模板html路径</span></div><div class="line">      minify:&#123;</div><div class="line">        removeComments:<span class="literal">true</span>,<span class="comment">//去注释</span></div><div class="line">        collapseWhitespace:<span class="literal">true</span><span class="comment">//去空格</span></div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>title</code>；html中的title，模板中配合&lt;%= htmlWebpackPlugin.options.title %&gt;可把设定值放入html的title中</li>
<li><code>inject</code>：打包后的js文件引用位置（head,body）默认放在body中。设置值为false后，通过把<code>&lt;script type=&quot;text/javascript&quot; src=&#39;&lt;%=htmlWebpackPlugin.files.chunks.index2.entry %&gt;&#39;&gt;&lt;/script&gt;</code>放在body或head中实现自定义。</li>
<li><code>filename</code>：html的文件名称(+路径)，这里是相对于output的路径(path)。改变默认值（index）后在devServer时要在端口后面加<code>/名称.html</code>本地访问。</li>
<li><code>template</code>：模板html的路径+名称。</li>
<li><code>chunks\encludeChunks</code>：用来决定生成的html中放进哪些chunk，默认全部放入。</li>
<li><code>minify</code>：精简html，<a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="external">详情看官网</a>。</li>
</ul>
<h3 id="五、开发模式"><a href="#五、开发模式" class="headerlink" title="五、开发模式"></a>五、开发模式</h3><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p><code>webpack-dev-server</code> 是一个简单的 web 服务器，并且能够实时重新加载(live reloading)。<br>npm 安装<br><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> webpack-<span class="built_in">dev</span>-server</div></pre></td></tr></table></figure></p>
<p>修改配置文件<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">devServer</span>:&#123;</div><div class="line">  <span class="attribute">contentBase</span>:path.<span class="built_in">resolve</span>(__dirname, <span class="string">"srccccc"</span>),</div><div class="line">  port:<span class="number">9000</span>,//端口</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>contentBase</code>：devServer会在内存中生成虚拟数据，contentBase是指定生成的地址，主要是为了文件引用这些虚拟数据提供路径（有模板文件时这个随便写）。</li>
</ul>
<p>之前在package.json中配置了<code>&quot;start&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;</code>，现在只要<code>npm run start</code>就会启动服务器了。</p>
<h4 id="热替换"><a href="#热替换" class="headerlink" title="热替换"></a>热替换</h4><p>之前的简单web服务器每次修改都会重新刷新整个页面，在页面十分大时，等待时间就会很长，而Hot Module Replacement实现局部刷新，提高开发效率，节约时间。</p>
<p>添加两个配置</p>
<ul>
<li><p>把<code>hot:true</code>加入到webpack-dev-server的配置项(devServer)里面。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">devServer</span>:&#123;</div><div class="line">  <span class="attribute">contentBase</span>:path.<span class="built_in">resolve</span>(__dirname, <span class="string">"srccccc"</span>),</div><div class="line">  port:<span class="number">9000</span>,</div><div class="line">  hot:true,//热替换选项</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
</li>
<li><p>把<code>new webpack.HotModuleReplacementPlugin()</code>加入到webpack的plugins中</p>
</li>
</ul>
<p>额外的插件<code>new webpack.NamedModulesPlugin()</code>，会在控制台显示你跟新文件的路径，利于调试。</p>
<h4 id="react-hot-loader"><a href="#react-hot-loader" class="headerlink" title="react-hot-loader"></a>react-hot-loader</h4><p>因为<code>React</code>有一些自己语法(JSX)是<code>HotModuleReplacementPlugin</code>实现不了的，<code>react-hot-loader</code>对它进行了改进，保证组件的状态可以在局部刷新是保存下来。例如一个输入框组件，你输入值后再改变其他组件，输入框的值不会丢失。</p>
<h5 id="添加两个配置"><a href="#添加两个配置" class="headerlink" title="添加两个配置"></a>添加两个配置</h5><ul>
<li><p>在入口文件<strong>之前</strong>添加<code>react-hot-loader/patch</code>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">entry:</span>[</div><div class="line">  <span class="string">'react-hot-loader/patch'</span>,</div><div class="line">  <span class="string">'./src/index'</span></div><div class="line">]</div></pre></td></tr></table></figure>
</li>
<li><p>在.babelrc中添加插件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>,<span class="string">"stage-0"</span>,<span class="string">"react"</span>],</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"react-hot-loader/babel"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>入口文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./Css/game'</span>;</div><div class="line"><span class="keyword">import</span> &#123; AppContainer &#125; <span class="keyword">from</span> <span class="string">'react-hot-loader'</span>;</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./BaseComponent/App'</span>;</div><div class="line"></div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">AppContainer</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">App</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">AppContainer</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// Hot Module Replacement API</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</div><div class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./BaseComponent/App'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> NextApp = <span class="built_in">require</span>(<span class="string">'./BaseComponent/App'</span>).default;</div><div class="line">    ReactDOM.render(</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">AppContainer</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">NextApp</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">AppContainer</span>&gt;</span>,</div><div class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">    );</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>顶层组件必须放在AppContainer中。大致意思就是模块热更新接收到组件更新的信号后重新render组件。</p>
<blockquote>
<p>官方文档给的HotContainer，但是我用报错，<code>react-hot-loader</code>export也是AppContainer，之后有问题再改。</p>
</blockquote>
<h4 id="Source-Maps"><a href="#Source-Maps" class="headerlink" title="Source Maps"></a>Source Maps</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>开发总是离不开调试，方便的调试能极大的提高开发效率，文件经过打包后，你不容易找到出错的地方，Source Maps就是来帮我们解决这个问题的，经过配置它可以精确到你源文件出错的位置。</p>
<h5 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h5><p>经过自己测试之后发现除了打包体积有不同，调试没啥区别，附上<a href="https://segmentfault.com/a/1190000006178770#articleHeader3" target="_blank" rel="external">大神博客</a>图片，日后再续<br><img src="/blog/myimages/webpack/sourceMap.png" alt=""><br>开发过程中建议使用<code>eval-source-map</code>(小型项目）若大型项目构建较慢可以使用<code>cheap-module-eval-source-map</code>。生产环境使用<code>cheap-module-eval-source-map</code>，但如果你不需要在生产环境中调试不要使用source map可以为你节省无敌多的代码体积。</p>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>这一部分主要介绍了webpack基础的部分，包括一些核心的属性以及开发环境的搭建，到目前为止可以搭建开发环境环境了，下面是我构建react开发环境的配置。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">const webpack=require(<span class="string">'webpack'</span>);</div><div class="line">const path=require(<span class="string">'path'</span>);</div><div class="line"><span class="comment">//引用插件</span></div><div class="line">const HtmlWebpackPlugin=require(<span class="string">'html-webpack-plugin'</span>);<span class="comment">//模板插件</span></div><div class="line">const CleanWebpackPlugin=require(<span class="string">'clean-webpack-plugin'</span>);<span class="comment">//模板插件</span></div><div class="line"></div><div class="line">const PATHS = &#123;</div><div class="line">  src: path.resolve(__dirname, <span class="string">'src'</span>),</div><div class="line">  build: path.resolve(__dirname, <span class="string">'build'</span>),</div><div class="line">  modules:path.resolve(__dirname,<span class="string">"node_modules"</span>)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports=&#123;</div><div class="line">  entry:[</div><div class="line">    <span class="string">'react-hot-loader/patch'</span>,<span class="comment">//开发过程中热替换</span></div><div class="line">    <span class="string">'./src/index'</span></div><div class="line">  ],</div><div class="line">  output:&#123;</div><div class="line">    path:PATHS.build,</div><div class="line">    filename:<span class="string">"js/[name].js"</span>,</div><div class="line">  &#125;,</div><div class="line">  devtool: <span class="string">'eval-source-map'</span>,<span class="comment">//'调试工具'</span></div><div class="line">  <span class="comment">//服务器配置</span></div><div class="line">  devServer:&#123;</div><div class="line">    contentBase:path.resolve(__dirname, <span class="string">"srccccc"</span>),</div><div class="line">    port:<span class="number">9000</span>,<span class="comment">//端口</span></div><div class="line">    hot:<span class="keyword">true</span>,<span class="comment">//热替换选项</span></div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.less$/</span>,</div><div class="line">        <span class="keyword">exclude</span>:PATHS.modules,</div><div class="line">        <span class="keyword">include</span>:PATHS.src,</div><div class="line">        <span class="comment">//使用postcss：放在less-loader前面，css-loader后面，不用importLoaders</span></div><div class="line">        use:[</div><div class="line">          <span class="string">'style-loader'</span>,</div><div class="line">          <span class="string">'css-loader'</span>,</div><div class="line">          <span class="string">'postcss-loader'</span>,</div><div class="line">          <span class="string">'less-loader'</span></div><div class="line">        ] , </div><div class="line">      &#125;, </div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="keyword">exclude</span>:PATHS.modules,</div><div class="line">        <span class="keyword">include</span>:PATHS.src,</div><div class="line">        use:[</div><div class="line">          <span class="string">'style-loader'</span>,<span class="comment">//style标签插入html中</span></div><div class="line">          <span class="string">'css-loader?importLoaders=1'</span>,<span class="comment">//@import的也能用,css-loader使在js中也能解析css</span></div><div class="line">          <span class="string">'postcss-loader'</span><span class="comment">//配置见postcss.config.js</span></div><div class="line">        ]</div><div class="line">      &#125;, </div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</div><div class="line">        <span class="keyword">exclude</span>:PATHS.modules,</div><div class="line">        <span class="keyword">include</span>:PATHS.src,</div><div class="line">        use:[</div><div class="line">          <span class="string">'babel-loader'</span>,<span class="comment">//配置见.babelrc</span></div><div class="line">        ]</div><div class="line">      &#125;, </div><div class="line">      &#123;</div><div class="line">        test:<span class="regexp">/\.(png|jpg|gif|svg)$/i</span>,</div><div class="line">        <span class="keyword">exclude</span>:PATHS.modules,</div><div class="line">        <span class="keyword">include</span>:PATHS.src,</div><div class="line">        use:[</div><div class="line">          <span class="string">'url-loader?limit=2048&amp;name=img/[name][hash].[ext]'</span>,         </div><div class="line">          <span class="string">'img-loader'</span><span class="comment">//压缩图片</span></div><div class="line">        ]</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test:<span class="regexp">/\.html$/</span>,</div><div class="line">        <span class="keyword">exclude</span>:PATHS.modules,</div><div class="line">        <span class="keyword">include</span>:PATHS.src,</div><div class="line">        use:[</div><div class="line">           &#123;</div><div class="line">            loader:<span class="string">'html-loader'</span>,</div><div class="line">            <span class="keyword">options</span>:&#123;</div><div class="line">              attrs:[<span class="string">'img:src'</span>,<span class="string">'a:href'</span>]<span class="comment">//筛选img和a</span></div><div class="line">            &#125;</div><div class="line">           &#125;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins:[</div><div class="line">    <span class="keyword">new</span> CleanWebpackPlugin(<span class="string">'build'</span>),<span class="comment">//清理打包文件</span></div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">      title:<span class="string">'My webpack-test-react'</span>,</div><div class="line">      <span class="keyword">inject</span>:<span class="string">'body'</span>,</div><div class="line">      filename:<span class="string">'admin.html'</span>,</div><div class="line">      template:<span class="string">'./src/templete/index.html'</span>,</div><div class="line">      minify:&#123;</div><div class="line">        removeComments:<span class="keyword">true</span>,<span class="comment">//去注释</span></div><div class="line">        collapseWhitespace:<span class="keyword">true</span><span class="comment">//去空格</span></div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">//热替换插件</span></div><div class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(),<span class="comment">//会在控制台显示你跟新文件的路径，利于调试</span></div><div class="line">  ],</div><div class="line">  resolve: &#123;</div><div class="line">    modules: [</div><div class="line">      PATHS.src,<span class="comment">//指定优先查找路径，要放在node_modules上面</span></div><div class="line">      <span class="string">"node_modules"</span></div><div class="line">    ],</div><div class="line">    <span class="comment">//后缀名自动补全，默认js,json。设置之后所有都不用带后缀</span></div><div class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.less'</span>, <span class="string">'.css'</span>], </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下一部分我会介绍webpack+react生产环境的配置包括一些代码的压缩分离优化。</p>
<h3 id="七、学习资料："><a href="#七、学习资料：" class="headerlink" title="七、学习资料："></a>七、学习资料：</h3><p>1、<a href="http://www.imooc.com/learn/802" target="_blank" rel="external">webpack慕课网视频</a>，可以大体浏览一般了解基本概念。由于版本差异里面的许多例子要结合最新文档。<br>2、<a href="https://segmentfault.com/a/1190000006178770" target="_blank" rel="external">博客资料</a>，可以跟着博主走一遍。<br>3、<a href="http://www.jianshu.com/p/794d573d2c53" target="_blank" rel="external">webpack+react</a>，react项目的构建。<br>4、<a href="https://doc.webpack-china.org/" target="_blank" rel="external">webpack中文文档</a></p>
]]></content>
      
        <categories>
            
            <category> Webpack </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Git命令记录]]></title>
      <url>/blog/2017/09/07/Git%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>主要是在学习Git过程中对自己常用命令的记录。<a id="more"></a><br>此篇主要是自己常用命令的记录，详细教程请移步<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" title="网站链接" target="_blank" rel="external">廖老师网站</a>。</p>
<h3 id="1、创建版本库"><a href="#1、创建版本库" class="headerlink" title="1、创建版本库"></a>1、创建版本库</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="$ git init"></a>$ git init</h4><p>把目录文件变成Git仓库，目录下的.git文件用来跟踪管理版本库，不要修改。</p>
<h3 id="2、工作区和缓存区"><a href="#2、工作区和缓存区" class="headerlink" title="2、工作区和缓存区"></a>2、工作区和缓存区</h3><h4 id="git-add"><a href="#git-add" class="headerlink" title="$ git add"></a>$ git add</h4><p>把工作区的文件添加到缓存区，<code>$ git add file1 file2</code>把file1,2添加到缓存区，<code>$ git add .</code>添加全部</p>
<h4 id="git-rm"><a href="#git-rm" class="headerlink" title="$ git rm"></a>$ git rm</h4><p>移除和上面add相反</p>
<h4 id="git-commit-m-“增加file”"><a href="#git-commit-m-“增加file”" class="headerlink" title="$ git commit -m “增加file”"></a>$ git commit -m “增加file”</h4><p>把缓存区提交到仓库目录下。只提交缓存目录下的（add的）。缓存区的概念做到了只提交你想提交的文件，做到了跟svn图形界面选择的功能。</p>
<h3 id="3、查看状态"><a href="#3、查看状态" class="headerlink" title="3、查看状态"></a>3、查看状态</h3><h4 id="git-status"><a href="#git-status" class="headerlink" title="$ git status"></a>$ git status</h4><p>查看仓库当前的状态，随时查看给出仓库的各个状态。</p>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="$ git diff"></a>$ git diff</h4><p><code>$ git diff readme.txt</code>在<code>$git status</code>告诉文件被修改过，用<code>$ git diff</code>查看修改的哪里。</p>
<h4 id="git-log"><a href="#git-log" class="headerlink" title="$ git log"></a>$ git log</h4><p>显示你最近（窗口没关之前）提交记录（commit）的日志。<code>$ git log --pretty=online</code>只显示在一行中，commit太多时使用。</p>
<h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="$ git reflog"></a>$ git reflog</h4><p>用来展示你所有的commit和reset的操作，包括commit id和HEAD</p>
<h3 id="4、版本回退"><a href="#4、版本回退" class="headerlink" title="4、版本回退"></a>4、版本回退</h3><h4 id="git-reset"><a href="#git-reset" class="headerlink" title="$ git reset"></a>$ git reset</h4><p><code>$ git reset --hard HEAD~10</code>回到10那个版本,HEAD当前版本，HEAD^上一个版本，HEAD^^上上个版本。<br><code>$ git reset --hard id号</code>HEAD id都可以在feflog中查看。</p>
<h3 id="5、远程仓库"><a href="#5、远程仓库" class="headerlink" title="5、远程仓库"></a>5、远程仓库</h3><p>在gitHub上创建个仓库，按照提示在本地操作即可，ssh需要配置key参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" title="网站链接" target="_blank" rel="external">廖老师网站</a>，origin可以替换为你的仓库名。之后再提交<code>$ git push origin master</code>。</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PureComponent]]></title>
      <url>/blog/2017/09/04/PureComponent/</url>
      <content type="html"><![CDATA[<p>这篇主要介绍了react浅比较的方法，对于自己这样react初学者理解PureComponent原理还是有帮助的。<a id="more"></a><br>先看react关于浅比较的源码：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span><span class="params">(x, y)</span> </span>&#123;</div><div class="line">	  <span class="comment">// SameValue algorithm</span></div><div class="line">	  <span class="keyword">if</span> (x === y) &#123;</div><div class="line">	    <span class="comment">// Steps 1-5, 7-10</span></div><div class="line">	    <span class="comment">// Steps 6.b-6.e: +0 != -0</span></div><div class="line">	    <span class="comment">// Added the nonzero y check to make Flow happy, but it is redundant</span></div><div class="line">	    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</div><div class="line">	  &#125; <span class="keyword">else</span> &#123;</div><div class="line">	    <span class="comment">// Step 6.a: NaN == NaN</span></div><div class="line">	    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span><span class="params">(objA, objB)</span> </span>&#123;</div><div class="line">	  <span class="keyword">if</span> (<span class="keyword">is</span>(objA, objB)) &#123;</div><div class="line">		<span class="comment">//指向同一个对象时</span></div><div class="line">	    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	  &#125;</div><div class="line">	</div><div class="line">	  <span class="keyword">if</span> (<span class="keyword">typeof</span> objA !== <span class="string">'object'</span> || objA === <span class="literal">null</span> || <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> || objB === <span class="literal">null</span>) &#123;</div><div class="line">	 	<span class="comment">//null和不是对象时</span></div><div class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	  &#125;</div><div class="line">	  <span class="comment">//两个不动对象的比较</span></div><div class="line">	  <span class="keyword">var</span> keysA = Object.keys(objA);</div><div class="line">	  <span class="keyword">var</span> keysB = Object.keys(objB);</div><div class="line">	</div><div class="line">	  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</div><div class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	  &#125;</div><div class="line">	</div><div class="line">	  <span class="comment">// Test for A's keys different from B.</span></div><div class="line">	  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</div><div class="line">	    <span class="keyword">if</span> (!hasOwnProperty.call(objB, keysA[i]) || !<span class="keyword">is</span>(objA[keysA[i]], objB[keysA[i]])) &#123;</div><div class="line">				<span class="comment">//这里只要是多层嵌套对象都会进来</span></div><div class="line">	      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	    &#125;</div><div class="line">	  &#125;</div><div class="line">	  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><h4 id="1、使用PureComponent，改变state但是却不render。"><a href="#1、使用PureComponent，改变state但是却不render。" class="headerlink" title="1、使用PureComponent，改变state但是却不render。"></a>1、使用PureComponent，改变state但是却不render。</h4><p>例如：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//<span class="keyword">state</span>=&#123;item:[<span class="string">"item"</span>]&#125;</div><div class="line">let items=this.<span class="keyword">state</span>.item;</div><div class="line">items.push(<span class="string">"new-item"</span>)</div><div class="line">this.<span class="built_in">set</span>State(</div><div class="line">	item:items</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>这里旧的state和新的state引用的同一个对象，浅比较总是成功（看上面源码），所以组件不会更新。<br><strong>解决方法：</strong><br><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//<span class="keyword">state</span>=&#123;item:[<span class="string">"item"</span>]&#125;</div><div class="line">this.<span class="built_in">set</span>State(</div><div class="line">	item:[<span class="string">"new-item"</span>,...items]</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>es6的扩展运算符，返回一个新数组，相当于item.concat(“new-item”)。这样组件就能更新了。</p>
<h4 id="2、多层嵌套结构PureComponent失去作用。"><a href="#2、多层嵌套结构PureComponent失去作用。" class="headerlink" title="2、多层嵌套结构PureComponent失去作用。"></a>2、多层嵌套结构PureComponent失去作用。</h4><p>PureComponent是对shouldComponentUpdate的封装，目的是进行状态的浅比较，减少不必要的更新，优化性能。但是对于多层嵌套的对象就失去了作用。<br>例如：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//<span class="keyword">state</span>=&#123;item:[<span class="string">"item"</span>]&#125;</div><div class="line">this.<span class="built_in">set</span>State(</div><div class="line">	item:[...items]</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>这里我没有进行任何state的变化，但是组件还是进行了render。原因：<code>is(objA[keysA[i]], objB[keysA[i]])</code>对于这个state来说就是<code>is(旧item,新item)</code>两个对象的===返回false,浅比较失败（react认为state有更新）render组件。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>react浅比较只是进行第一层的比较，所以我们在写组件时尽量考虑state的扁平化，同时使用PureComponent优化，会很大的优化性能。</p>
]]></content>
      
        <categories>
            
            <category> React </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[属性遍历]]></title>
      <url>/blog/2017/08/31/%E5%B1%9E%E6%80%A7%E9%81%8D%E5%8E%86/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Json&Object]]></title>
      <url>/blog/2017/08/31/Json-Object/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[NodeList和slice]]></title>
      <url>/blog/2017/08/31/NodeList%E5%92%8Cslice/</url>
      <content type="html"><![CDATA[<p>主要介绍了NodeList，以及扩展原型的方法<a id="more"></a></p>
<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>NodeList是一个类数组对象,由Node.childNodes和document.qerySelectorAll返回。</p>
<h3 id="二、属性方法"><a href="#二、属性方法" class="headerlink" title="二、属性方法"></a>二、属性方法</h3><p>根据MDN文档，NodeList有length属性和item方法（返回NodeList对象中指定索引的节点,如果索引越界,则返回null.等价的写法是nodeList[idx], 不过这种情况下越界访问将返回undefined.）。</p>
<h3 id="三、描述"><a href="#三、描述" class="headerlink" title="三、描述"></a>三、描述</h3><p><strong>一个“有时实时”的集合</strong><br>大多数情况下，NodeList 对象都是个实时集合。意思是说，如果文档中的节点树发生变化，则已经存在的 NodeList 对象也可能会变化。例如，Node.childNodes 是实时的：<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">parent</span> = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>);</div><div class="line"><span class="built_in">var</span> child_nodes = <span class="built_in">parent</span>.childNodes;</div><div class="line"><span class="built_in">console</span>.log(child_nodes.length); <span class="comment">// 如果假设结果是“2”</span></div><div class="line"><span class="built_in">parent</span>.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>));</div><div class="line"><span class="built_in">console</span>.log(child_nodes.length); <span class="comment">// 此时的输出是“3”</span></div></pre></td></tr></table></figure></p>
<p>在另一些情况下，NodeList 是一个静态集合，也就意味着随后对文档对象模型的任何改动都不会影响集合的内容。document.querySelectorAll 返回一个静态的 NodeList。</p>
<p>特别是当你选择如何遍历 NodeList 中所有项，或缓存列表长度的时候，最好牢记这种区分。</p>
<h3 id="四、不能使用数组的方法"><a href="#四、不能使用数组的方法" class="headerlink" title="四、不能使用数组的方法"></a>四、不能使用数组的方法</h3><h4 id="1、不同浏览器的支持不同"><a href="#1、不同浏览器的支持不同" class="headerlink" title="1、不同浏览器的支持不同"></a>1、不同浏览器的支持不同</h4><p>chrome:<br><img src="/blog/myimages/NodeList/p1.png" alt="chrome中图片"><br>火狐：<br><img src="/blog/myimages/NodeList/p3.png" alt="火狐中图片"><br>360：<br><img src="/blog/myimages/NodeList/p2.png" alt="360中图片"><br>可以对比看出原型链一致 myNodeList –&gt; NodeList.prototype –&gt; Object.prototype,但是NodeList.prototype方法略有不同，高版本的浏览器多出了很多新的方法（forEach、keys）。</p>
<h4 id="2、为啥不能使用数组方法"><a href="#2、为啥不能使用数组方法" class="headerlink" title="2、为啥不能使用数组方法"></a>2、为啥不能使用数组方法</h4><p><img src="/blog/myimages/NodeList/p4.png" alt="数组继承"><br>可以看出数组的原型链 myArray –&gt; Array.prototype –&gt; Object.prototype，而且数组的map、forEach等方法放在Array.prototype上所以用不了。</p>
<h4 id="3、解决方式"><a href="#3、解决方式" class="headerlink" title="3、解决方式"></a>3、解决方式</h4><h5 id="1、把-Array-prototype-上的方法添加到-NodeList-prototype-上"><a href="#1、把-Array-prototype-上的方法添加到-NodeList-prototype-上" class="headerlink" title="1、把 Array.prototype 上的方法添加到 NodeList.prototype 上"></a>1、把 Array.prototype 上的方法添加到 NodeList.prototype 上</h5><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var arrayMethods=Object.getOwnPropertyNames(Array.prototype);//获取数组原型方法(方法都是不可枚举的)</div><div class="line">arrayMethods.forEach(<span class="function"><span class="keyword">function</span>(</span><span class="function"><span class="keyword">method</span>)&#123;</span></div><div class="line">	<span class="keyword">if</span>(<span class="function"><span class="keyword">method</span>!=</span>=<span class="string">"length"</span>)&#123;//过滤length</div><div class="line">		NodeList.prototype[<span class="function"><span class="keyword">method</span>]=</span>Array.prototype[<span class="function"><span class="keyword">method</span>];			</span></div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上面的方法扩展了NodeList原型，添加了Array.prototype的方法。</p>
<h5 id="2、将NodeList作为this传递给数组方法。"><a href="#2、将NodeList作为this传递给数组方法。" class="headerlink" title="2、将NodeList作为this传递给数组方法。"></a>2、将NodeList作为this传递给数组方法。</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> divs = document.querySelectorAll(<span class="string">"div"</span>);</div><div class="line"><span class="keyword">var</span> <span class="keyword">forEach</span>=<span class="keyword">Array</span>.prototype.<span class="keyword">forEach</span>;</div><div class="line"><span class="keyword">forEach</span>.call(divs,<span class="function"><span class="keyword">function</span><span class="params">(div)</span></span>&#123;</div><div class="line">	div<span class="comment">//这里就会得到Dom元素</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>通过这样的方式可以实现NodeList调用forEach等方法<br>注：<code>Object.getOwnPropertyNames(obj)</code>返回所有自身属性的属性名(包括不可枚举属性)组成的数组。</p>
<h4 id="4、将NodeList转换为数组"><a href="#4、将NodeList转换为数组" class="headerlink" title="4、将NodeList转换为数组"></a>4、将NodeList转换为数组</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div_list = <span class="built_in">document</span>.<span class="built_in">querySelectorAll</span>(<span class="string">'div'</span>); <span class="comment">// 返回 NodeList</span></div><div class="line"><span class="keyword">var</span> div_array = Array.prototype.slice.call(div_list); <span class="comment">// 将 NodeList 转换为数组</span></div><div class="line"><span class="keyword">var</span> div_array=[].slice.call(div_list)<span class="comment">//简写</span></div></pre></td></tr></table></figure>
<p>slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝（引用类型共用）到一个新数组对象。原始数组不会被修改。接受两个参数，省略哪一个到哪一端极限（都省略返回完整新数组）。</p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[事件]]></title>
      <url>/blog/2017/08/29/%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>主要介绍了原生事件的概念和兼容方法。<a id="more"></a></p>
<h3 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h3><p>1、传统方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	event<span class="comment">//事件对象</span></div><div class="line">	<span class="keyword">this</span><span class="comment">//btn,引用当前元素</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//移除</span></div><div class="line">btn.onclick=<span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<p>特点：只能绑定一个，后边的会覆盖前面的<br>2、addEventListener<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.addEventListener(<span class="string">"click"</span>,handler,<span class="literal">false</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	event<span class="comment">//事件对象</span></div><div class="line">	<span class="keyword">this</span><span class="comment">//btn,引用当前元素</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//移除</span></div><div class="line">btn.removeEventListener(<span class="string">"click"</span>,handler,<span class="literal">false</span>);</div></pre></td></tr></table></figure></p>
<p>特点：绑定多个，按顺序执行。匿名函数解除不了。<br>3、attachEvent(IE)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>,handler);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	event<span class="comment">//事件对象</span></div><div class="line">	<span class="keyword">this</span><span class="comment">//window</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//移除</span></div><div class="line">btn.detachEvent(<span class="string">"onclick"</span>,handler)</div></pre></td></tr></table></figure></p>
<p>特点：绑定多个，按倒序触发。click=&gt;onclick。this指向全局。</p>
<h3 id="一、事件对象"><a href="#一、事件对象" class="headerlink" title="一、事件对象"></a>一、事件对象</h3><p>在触发DOM上的某个事件时，会产生一个事件对象event，它包含着所有与事件有关的信息。事件对象(event)都可以在事件处理函数中访问到。<br>1、type：事件类型，可以用来判断触发的是那个事件。（ie,dom）<br>2、target:事件源对象：哪个元素触发的。（dom,ie是srcElement）<br>3、currentTarget:注册事件的那个元素。（dom,ie没有）</p>
<h3 id="二、跨浏览器的事件处理方法"><a href="#二、跨浏览器的事件处理方法" class="headerlink" title="二、跨浏览器的事件处理方法"></a>二、跨浏览器的事件处理方法</h3><p>这是《javascript高级程序设计》提供的方法，基本解决了浏览器兼容问题。也是对前面的总结。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil=&#123;</div><div class="line">	<span class="comment">//添加事件</span></div><div class="line">	addHandler:<span class="keyword">function</span>(element,<span class="keyword">type</span>,handler)&#123;</div><div class="line">		<span class="keyword">if</span>(element<span class="variable">.addEventListener</span>)&#123;</div><div class="line">			element<span class="variable">.addEventListener</span>(<span class="keyword">type</span>,handler,false);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element<span class="variable">.attachEvent</span>)&#123;</div><div class="line">			element<span class="variable">.attachEvent</span>(<span class="string">"on"</span>+<span class="keyword">type</span>,handler);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			element[<span class="string">"on"</span>+<span class="keyword">type</span>]=handler;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//移除事件</span></div><div class="line">	removeHandler:<span class="keyword">function</span>(element,<span class="keyword">type</span>,handler)&#123;</div><div class="line">		<span class="keyword">if</span>(element<span class="variable">.removeEventListener</span>)&#123;</div><div class="line">			element<span class="variable">.removeEventListener</span>(<span class="keyword">type</span>,handler,false);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element<span class="variable">.detachEvent</span>)&#123;</div><div class="line">			element<span class="variable">.detachEvent</span>(<span class="string">"on"</span>+<span class="keyword">type</span>,handler);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			element[<span class="string">"on"</span>+<span class="keyword">type</span>]=<span class="literal">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//获取事件对象</span></div><div class="line">	getEvent:<span class="keyword">function</span>(<span class="keyword">event</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">event</span>?<span class="keyword">event</span>:window<span class="variable">.event</span>;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//获取事件源对象</span></div><div class="line">	getTarget:<span class="keyword">function</span>(<span class="keyword">event</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">event</span><span class="variable">.target</span>||<span class="keyword">event</span><span class="variable">.srcElement</span>;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//阻止默认事件</span></div><div class="line">	preventDefault:<span class="keyword">function</span>(<span class="keyword">event</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">event</span><span class="variable">.preventDefault</span>)&#123;</div><div class="line">			<span class="keyword">event</span><span class="variable">.preventDefault</span>();</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">event</span><span class="variable">.returnValue</span>=false;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//阻止冒泡</span></div><div class="line">	stopPropagation:<span class="keyword">function</span>(<span class="keyword">event</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">event</span><span class="variable">.stopPropagation</span>)&#123;</div><div class="line">			<span class="keyword">event</span><span class="variable">.stopPropagation</span>();</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">event</span><span class="variable">.cancelBubble</span>=true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>应用：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">function <span class="title">showValue</span>(<span class="params"><span class="keyword">event</span></span>)</span>&#123;</div><div class="line">	<span class="comment">//获取事件对象</span></div><div class="line">	e=EventUtil.getEvent(<span class="keyword">event</span>);</div><div class="line">	<span class="comment">//阻止冒泡</span></div><div class="line">	EventUtil.stopPropagation(e);</div><div class="line">	<span class="comment">//获取事件源对象</span></div><div class="line">	<span class="keyword">var</span> eTarget=EventUtil.getTarget(e);</div><div class="line">	console.log(eTarget.<span class="keyword">value</span>)</div><div class="line">&#125;</div><div class="line">EventUtil.addHandler(div,<span class="string">"click"</span>,showValue)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[迭代方法]]></title>
      <url>/blog/2017/08/16/%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>主要介绍了ES5的几个迭代方法（filter、map、forEach、every、some）<a id="more"></a></p>
<h3 id="一、map方法"><a href="#一、map方法" class="headerlink" title="一、map方法"></a>一、map方法</h3><p>map方法返回一个数组，这个新数组的每一项依次对应原数组。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arrMap=arr.map(<span class="function"><span class="keyword">function</span><span class="params">(item,index,array)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> item*<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line">arrMap<span class="comment">//[2,4,6,8,10]</span></div></pre></td></tr></table></figure></p>
<p>不会改变原数组，返回新数组</p>
<h3 id="二、forEach方法"><a href="#二、forEach方法" class="headerlink" title="二、forEach方法"></a>二、forEach方法</h3><p>forEach方法没有返回值,跟for差不多，不能像for一样break打断全部，可以return结束本次。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</div><div class="line">	<span class="comment">//在这里面执行某些操作</span></div><div class="line">	<span class="keyword">if</span>(index===<span class="number">3</span>)&#123;</div><div class="line">		<span class="built_in">console</span>.log(item);</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>不会改变原数组，也不返回新数组，只是针对数组的每一项做操作。</p>
<h3 id="三、filter方法"><a href="#三、filter方法" class="headerlink" title="三、filter方法"></a>三、filter方法</h3><p>filter方法返回新的数组（符合条件项组成的），用来查询符合某些条件的所有数组项。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arrFilter=arr.filter(<span class="function"><span class="keyword">function</span><span class="params">(item,index,array)</span></span>&#123;</div><div class="line">	<span class="comment">//返回所有数组项大于2的</span></div><div class="line">	<span class="keyword">return</span> item&gt;<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line">arrFilter<span class="comment">//[3,4,5]</span></div></pre></td></tr></table></figure></p>
<p>不会改变原数组，用来筛选挺好</p>
<h3 id="四、every方法"><a href="#四、every方法" class="headerlink" title="四、every方法"></a>四、every方法</h3><p>对数组的每一项运行给定函数，如果每一项都返回true，则返回true。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arrEvery=arr.every(<span class="function"><span class="keyword">function</span><span class="params">(item,index,array)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> item&gt;<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line">arrEvery<span class="comment">//flase</span></div></pre></td></tr></table></figure></p>
<p>不会改变原数组，返回值true或false。</p>
<h3 id="五、some方法"><a href="#五、some方法" class="headerlink" title="五、some方法"></a>五、some方法</h3><p>和every类似，只要有一项返回true，则返回true。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> arrSome=arr.some(<span class="function"><span class="keyword">function</span><span class="params">(item,index,array)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> item&gt;<span class="number">2</span>;</div><div class="line">&#125;)</div><div class="line">arrSome<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>注：上面的函数参数都是可选的。</p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[继承]]></title>
      <url>/blog/2017/08/07/%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p>对《JavaScript高级程序设计》关于继承的总结<a id="more"></a></p>
<h3 id="一、单独使用原型链实现继承"><a href="#一、单独使用原型链实现继承" class="headerlink" title="一、单独使用原型链实现继承"></a>一、单独使用原型链实现继承</h3><h4 id="1、特点："><a href="#1、特点：" class="headerlink" title="1、特点："></a>1、特点：</h4><p>父类型的实例是子类型的原型，所有的子类型实例共享父实例的方法属性。<br>问题：子类型实例化时不能向父类传参，对于引用类型的值时，改一个全改。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span></span>&#123;</div><div class="line">	this.name=name;</div><div class="line">	this.color=[<span class="string">"black"</span>,<span class="string">"white"</span>,<span class="string">"yellow"</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">(age)</span></span>&#123;</div><div class="line">	this.age=age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">Parent</span>.prototype=<span class="keyword">new</span> Person(<span class="string">"lee"</span>);</div><div class="line"><span class="keyword">Parent</span>.prototype.constructor=<span class="keyword">Parent</span>;</div><div class="line">parent1=<span class="keyword">new</span> <span class="keyword">Parent</span>(<span class="number">30</span>);</div><div class="line">parent2=<span class="keyword">new</span> <span class="keyword">Parent</span>(<span class="number">32</span>);</div></pre></td></tr></table></figure></p>
<p>注：所有对象都是Object构造函数的实例，原型链的最顶端就是Object，原型对象也是对象。</p>
<h3 id="二、构造函数绑定"><a href="#二、构造函数绑定" class="headerlink" title="二、构造函数绑定"></a>二、构造函数绑定</h3><h4 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点:"></a>1、特点:</h4><p>在子类构造函数内部调用超类构造函数，就是在子类中把父类所有的属性方法复制一遍。<br>问题：跟原型无关，子类无法使用父类原型的方法，所有的方法只能使用构造函数的方法，但可以自由传参，所有实例都有自己的一份属性方法，没有引用类型的问题。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	Human.call(<span class="keyword">this</span>,name);</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age,color</span>)</span>&#123;</div><div class="line">	Person.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">	<span class="keyword">this</span>.color=<span class="built_in">color</span>;</div><div class="line">&#125;</div><div class="line">parent1=<span class="keyword">new</span> Parent(<span class="string">"lee"</span>,<span class="number">30</span>,<span class="string">"black"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="三、组合方式实现继承"><a href="#三、组合方式实现继承" class="headerlink" title="三、组合方式实现继承"></a>三、组合方式实现继承</h3><h4 id="1、特点：-1"><a href="#1、特点：-1" class="headerlink" title="1、特点："></a>1、特点：</h4><p>结合了原型链和构造函数的优点，私有的属性方法写在构造函数中，共享的属性方法写在原型对象中。<br>问题：在把子构造函数的原型间接指向父构造函数的原型过程中多调用了一次父超类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.color=[<span class="string">"black"</span>,<span class="string">"white"</span>,<span class="string">"yellow"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);<span class="comment">//把父类的属性方法拷贝了一份</span></div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">Parent.prototype=<span class="keyword">new</span> Person();<span class="comment">//多调用的那一次</span></div><div class="line">Parent.prototype.constructor=Parent;</div><div class="line">parent1=<span class="keyword">new</span> Parent(<span class="string">"lee"</span>,<span class="number">24</span>);</div></pre></td></tr></table></figure></p>
<h3 id="四、寄生组合式继承"><a href="#四、寄生组合式继承" class="headerlink" title="四、寄生组合式继承"></a>四、寄生组合式继承</h3><h4 id="1、特点：-2"><a href="#1、特点：-2" class="headerlink" title="1、特点："></a>1、特点：</h4><p>利用空对象代替父类实例解决了调用两次父构造函数的问题。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">parent,child</span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> temp=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">	temp.prototype=<span class="built_in">parent</span>.prototype;</div><div class="line">	child.prototype=<span class="keyword">new</span> temp();</div><div class="line">	child.prototype.constructor=child;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.color=[<span class="string">"black"</span>,<span class="string">"white"</span>,<span class="string">"yellow"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">inheritPrototype(Person,Parent);</div><div class="line">parent1=<span class="keyword">new</span> Parent(<span class="string">"lee"</span>,<span class="number">24</span>);</div></pre></td></tr></table></figure></p>
<h3 id="五、拷贝继承"><a href="#五、拷贝继承" class="headerlink" title="五、拷贝继承"></a>五、拷贝继承</h3><h4 id="1、特点：-3"><a href="#1、特点：-3" class="headerlink" title="1、特点："></a>1、特点：</h4><p>把父构造函数原型上的方法属性复制一份给子构造函数原型来实现继承。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">parent,child</span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> p=<span class="built_in">parent</span>.prototype;</div><div class="line">	<span class="built_in">var</span> c=child.prototype;</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">var</span> i <span class="keyword">in</span> p)&#123;</div><div class="line">		c[i]=p[i];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.color=[<span class="string">"black"</span>,<span class="string">"white"</span>,<span class="string">"yellow"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">extendCopy(Person,Parent);</div><div class="line">parent1=<span class="keyword">new</span> Parent(<span class="string">"lee"</span>,<span class="number">24</span>);</div></pre></td></tr></table></figure></p>
<p>各自有各自的原型，只是子的把父的原型复制了一遍，因为都是在原型的操作（实例不能直接修改原型）不涉及引用类型的问题。</p>
<h3 id="六、不使用构造函数继承"><a href="#六、不使用构造函数继承" class="headerlink" title="六、不使用构造函数继承"></a>六、不使用构造函数继承</h3><h4 id="1、原型式继承"><a href="#1、原型式继承" class="headerlink" title="1、原型式继承"></a>1、原型式继承</h4><h5 id="1、使用函数的方式实现"><a href="#1、使用函数的方式实现" class="headerlink" title="1、使用函数的方式实现"></a>1、使用函数的方式实现</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">	name:<span class="string">"lee"</span>,</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	F.prototype=<span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="keyword">parent</span>=object(person);</div></pre></td></tr></table></figure>
<p>这个object函数只做了一件事，把子对象的原型指向父对象，这样子对象就能使用父对象的方法了。</p>
<h5 id="2、Object-create-方法实现"><a href="#2、Object-create-方法实现" class="headerlink" title="2、Object.create()方法实现"></a>2、Object.create()方法实现</h5><p><code>Object.create()</code>方法接受两个参数，在只有一个参数的情况下，它和上面的object方法的作用是一致的。  </p>
<p><code>Object.create()</code>的第二个参数和<code>Object.defineProperties()</code>方法的第二个参数格式相同,通过这样方式定义的属性是自有属性，但是默认不可重写。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">	<span class="attr">name</span>:<span class="string">"lee"</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> parent=<span class="built_in">Object</span>.create(person,&#123;</div><div class="line">	<span class="attr">name</span>:&#123;</div><div class="line">		<span class="attr">value</span>:<span class="string">"li"</span>,</div><div class="line">		<span class="attr">writable</span>:<span class="literal">true</span><span class="comment">//设置为可以重写</span></div><div class="line">	&#125;,</div><div class="line">	<span class="attr">say</span>:&#123;</div><div class="line">		<span class="attr">value</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line">parent.say();<span class="comment">//li</span></div></pre></td></tr></table></figure></p>
<h4 id="2、浅拷贝"><a href="#2、浅拷贝" class="headerlink" title="2、浅拷贝"></a>2、浅拷贝</h4><p>特点：把父对象的方法属性拷贝到子对象上。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> c=&#123;&#125;;</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">var</span> i <span class="keyword">in</span> p)&#123;</div><div class="line">		c[i]=p[i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"><span class="built_in">var</span> person=&#123;</div><div class="line">	<span class="attribute">name</span>:<span class="string">"lee"</span>,</div><div class="line">&#125;</div><div class="line"><span class="built_in">var</span> <span class="built_in">parent</span>=extendCopy(person);</div></pre></td></tr></table></figure></p>
<p>在涉及引用类型的值时，会出现共享的问题（只是复制了地址）。</p>
<h4 id="3、深拷贝"><a href="#3、深拷贝" class="headerlink" title="3、深拷贝"></a>3、深拷贝</h4><p>把包含引用类型值是递归调用浅拷贝。这要操作之后子类拥有所有父类的内容，子父相互独立可以放心使用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function deepCopy(p,<span class="built_in">c</span>)&#123;</div><div class="line">	<span class="keyword">var</span> <span class="built_in">c</span>=<span class="built_in">c</span>||&#123;&#125;;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> p)&#123;</div><div class="line">		<span class="keyword">if</span>(typeof p[i]===<span class="string">"object"</span>)&#123;</div><div class="line">			<span class="built_in">c</span>[i]=(p[i].constructor===<span class="type">Array</span>)?[]:&#123;&#125;;<span class="comment">//确定是否数组</span></div><div class="line">			deepCopy(p[i],<span class="built_in">c</span>[i]);<span class="comment">//递归调用</span></div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="built_in">c</span>[i]=p[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">c</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=&#123;</div><div class="line">	name:<span class="string">"lee"</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> parent=deepCopay(person);</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[css知识点]]></title>
      <url>/blog/2017/08/03/css%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>一些css知识和使用技巧的总结<a id="more"></a></p>
<h3 id="一、-nth-of-type-n-和-nth-child-n"><a href="#一、-nth-of-type-n-和-nth-child-n" class="headerlink" title="一、:nth-of-type(n)和:nth-child(n)"></a>一、:nth-of-type(n)和:nth-child(n)</h3><p>p:nth-of-type(2)：选择属于其父元素第二个 </p><p> 元素的每个 </p><p> 元素。<br>p:nth-child(2)：选择属于其父元素的唯一子元素的每个 </p><p> 元素。<br>字面意思就是:nth-of-type(n)是分类的，而:nth-child(n)不分类（只要是子元素都算）。<br>例如：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;div id='d1'&gt;</span></div><div class="line">	<span class="params">&lt;p&gt;</span>我是p<span class="params">&lt;/p&gt;</span></div><div class="line">	<span class="params">&lt;div&gt;</span>我是div<span class="params">&lt;/div&gt;</span></div><div class="line">	<span class="params">&lt;p&gt;</span>我是p<span class="params">&lt;/p&gt;</span></div><div class="line">	<span class="params">&lt;div&gt;</span>我是div<span class="params">&lt;/div&gt;</span></div><div class="line"><span class="params">&lt;/div&gt;</span></div><div class="line"><span class="meta">#d1 div:nth-of-type(1)&#123;</span></div><div class="line"><span class="symbol">	background:</span> <span class="meta">#ddd;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/blog/myimages/cssPointer/p1.png" alt="效果"><br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;div id='d1'&gt;</span></div><div class="line">	<span class="params">&lt;p&gt;</span>我是p<span class="params">&lt;/p&gt;</span></div><div class="line">	<span class="params">&lt;div&gt;</span>我是div<span class="params">&lt;/div&gt;</span></div><div class="line">	<span class="params">&lt;p&gt;</span>我是p<span class="params">&lt;/p&gt;</span></div><div class="line">	<span class="params">&lt;div&gt;</span>我是div<span class="params">&lt;/div&gt;</span></div><div class="line"><span class="params">&lt;/div&gt;</span></div><div class="line"><span class="meta">#d1 div:nth-child(1)&#123;</span></div><div class="line"><span class="symbol">	background:</span> <span class="meta">#ddd;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/blog/myimages/cssPointer/p2.png" alt="效果"><br>就是带着type的都会分类，不带的不会分类，子元素都算上。感觉:nth-of-type(n)比较符合使用习惯。<br>注：这些都不能和类选择器，id选择器结合使用。</p>
<h3 id="二、hover的一个妙用"><a href="#二、hover的一个妙用" class="headerlink" title="二、hover的一个妙用"></a>二、hover的一个妙用</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">	&lt;<span class="built_in">li</span>&gt;第一个<span class="built_in">li</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">	&lt;<span class="built_in">li</span> class=<span class="string">"second"</span>&gt;第二个<span class="built_in">li</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">	&lt;<span class="built_in">li</span>&gt;第三个<span class="built_in">li</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">	&lt;<span class="built_in">li</span>&gt;第四个<span class="built_in">li</span>&lt;/<span class="built_in">li</span>&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">ul:hover .<span class="built_in">second</span>&#123;</div><div class="line">	<span class="built_in">background</span>:#ddd;</div><div class="line">	<span class="built_in">color</span>:#cc80dd;</div><div class="line">	padding-left:200px;</div><div class="line">	margin-top: 100px;</div><div class="line">	<span class="built_in">height</span>:100px;</div><div class="line">&#125;</div><div class="line"><span class="built_in">li</span>&#123;</div><div class="line">	transition:all 1s;</div><div class="line">	<span class="built_in">height</span>:20px;</div><div class="line">	<span class="comment">/*其余的都有默认值*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>意思是#d1的hover事件但是#d1的子元素样式改变(所有的样式改变都ok)。所有的浏览器都支持，之要用js写的功能，css就能搞定，是不是很厉害啊。<br>注：所有hover之后的样式，hover之前都要有，不然会闪回。</p>
]]></content>
      
        <categories>
            
            <category> CSS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[创建对象]]></title>
      <url>/blog/2017/08/02/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>对《JavaScript高级程序设计》关于创建对象方法的总结<a id="more"></a></p>
<h3 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h3><p>概述：在js中工厂模式可以看做是一种函数，用来封装创建对象的细节，最后返回一个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">funciton Person(name,age)&#123;</div><div class="line">	<span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.name=name;</div><div class="line">	o.age=age;</div><div class="line">	o.intr=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="二、构造函数模式"><a href="#二、构造函数模式" class="headerlink" title="二、构造函数模式"></a>二、构造函数模式</h3><h4 id="1、理解构造函数"><a href="#1、理解构造函数" class="headerlink" title="1、理解构造函数"></a>1、理解构造函数</h4><p>构造函数也是函数的一种，只不过具有创建对象的作用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">	<span class="keyword">this</span>.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"is"</span>+<span class="keyword">this</span>.age)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Lee"</span>,<span class="number">24</span>);</div></pre></td></tr></table></figure></p>
<p>Person构造函数创建person实例时，new操作符做了这样几件事：<br>1、创建一个新对象。<br>2、将对象进行[[prototype]]连接。<br>3、将Person的this指向person1。<br>4、按照构造函数初始化person1(添加属性方法)。<br>5、返回person1这个新对象。<br>实例有一个constructor属性指向他的构造函数Person。<br><code>person1.constructor==Person</code><br>instanceof用来检测对象(只要是对象就行)的类型。<br><code>person1 instanceof Person;//true</code></p>
<h4 id="2、构造函数当做函数。"><a href="#2、构造函数当做函数。" class="headerlink" title="2、构造函数当做函数。"></a>2、构造函数当做函数。</h4><h5 id="1、直接调用。"><a href="#1、直接调用。" class="headerlink" title="1、直接调用。"></a>1、直接调用。</h5><p>不使用new操作符来调用构造函数时，this指向window，属性和方法都会添加给window对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=<span class="string">"lee"</span>;</div><div class="line">&#125;</div><div class="line">Fn();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);<span class="comment">//lee</span></div></pre></td></tr></table></figure></p>
<p>在全局调用，这个没啥好说的，会把name添加到window上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=<span class="string">"lee"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	Fn();</div><div class="line">	<span class="keyword">this</span>.age=<span class="number">24</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ha=<span class="keyword">new</span> anFn();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);<span class="comment">//lee</span></div></pre></td></tr></table></figure></p>
<p>这种Fn是在anFn内部调用，在Fn()执行时this绑定没完成，所以这时的this还是指window，从而把属性方法绑定在window上。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=<span class="string">"lee"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anFn</span><span class="params">()</span></span>&#123;</div><div class="line">	Fn.apply(<span class="keyword">this</span>);</div><div class="line">	<span class="keyword">this</span>.age=<span class="number">24</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="2、call、apply绑定"><a href="#2、call、apply绑定" class="headerlink" title="2、call、apply绑定"></a>2、call、apply绑定</h5><p>使用call、apply在某个对象中调用构造函数，这也是构造函数继承的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=<span class="string">"lee"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Fn.call(o);</div><div class="line"><span class="built_in">console</span>.log(o.name);<span class="comment">//lee</span></div></pre></td></tr></table></figure></p>
<p>这两个方法的第一个参数就是this绑定的对象,在非严格模式下null或者undefined,将会使用全局对象代替。<br>apply的第二个参数是一个数组，在调用时会把这个数组内容转换为参数。可以用来展开数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> args=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(x+y+z);</div><div class="line">&#125;</div><div class="line">f.apply(<span class="literal">null</span>,args)<span class="comment">//6</span></div></pre></td></tr></table></figure></p>
<h4 id="3、构造函数的特点"><a href="#3、构造函数的特点" class="headerlink" title="3、构造函数的特点"></a>3、构造函数的特点</h4><p>1、构造函数的主要问题就是每个方法都要在实例上创建一遍。<br>2、可以自由的传递参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">	<span class="keyword">this</span>.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"is"</span>+<span class="keyword">this</span>.age)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"lee"</span>,<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"james"</span>,<span class="number">28</span>);</div></pre></td></tr></table></figure></p>
<p>上面我们创建了一个Person的构造函数，对于它的两个实例person1和person来说，say方法显然可以不用再每个对象中都创建一遍。那我们其实可以写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">	<span class="keyword">this</span>.say=say</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"lee"</span>,<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"james"</span>,<span class="number">28</span>);</div></pre></td></tr></table></figure></p>
<p>在这里person1和person2共享全局中的say，虽然这样不必在每个实例中都创建相同的say函数，但是把所有的共享方法放在全局中又不是最好的解决办法。于是原型模式就出现了。<br>注：感觉跟原型的原理是一样的，只不过原型的封装性好。</p>
<h3 id="三、原型模式"><a href="#三、原型模式" class="headerlink" title="三、原型模式"></a>三、原型模式</h3><h4 id="1、特点："><a href="#1、特点：" class="headerlink" title="1、特点："></a>1、特点：</h4><p>1、实例取得相同的属性（实例时不能传参）。<br>2、对于引用类型的值，所有实例共享同一个（改一个全改）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name=<span class="string">"lee"</span>;</div><div class="line">Person.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</div></pre></td></tr></table></figure></p>
<p>原型模式可以把共有的属性方法放在函数的原型中解决了构造函数每个实例都要创建相同方法属性的问题。</p>
<h4 id="2、关于原型的方法："><a href="#2、关于原型的方法：" class="headerlink" title="2、关于原型的方法："></a>2、关于原型的方法：</h4><p>1、<code>Object.getPrototyOf()</code>这个方法可以得到实例的原型。<code>Object.getPrototyOf(person1)</code><br>2、<code>isPrototypeOf()</code>用来判断某个原型对象和实例之间的关系。<code>Person.prototype.isPrototypeOf(person1)</code>。<br>3、<code>hasOwnProperty()</code>用来检测实例是否本地具有某个属性，还是继承自原型。<code>person1.hasOwnProperty(&quot;name&quot;)</code></p>
<h3 id="四、构造函数和原型链组合"><a href="#四、构造函数和原型链组合" class="headerlink" title="四、构造函数和原型链组合"></a>四、构造函数和原型链组合</h3><h4 id="1、特点：-1"><a href="#1、特点：-1" class="headerlink" title="1、特点："></a>1、特点：</h4><p>1、共享的属性方法放在原型对象中。<br>2、不共享的属性方法放在构造函数中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">constructor</span>:Person,</div><div class="line">	<span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"lee"</span>,<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"li"</span>,<span class="number">18</span>);</div></pre></td></tr></table></figure></p>
<p>这里person1、person2都有各自的name、age属性，同时他们又通过原型链共享say方法。这种方法结合了构造函数和原型链的优点，被广泛使用来创建对象。<br>注：这里使用字面量的形式重写了Person的原型，{}是Object创建的实例所以它的原型中的constructor自然指向Object构造函数，这里在{}内部重写constructor属性相当于覆盖了它原型链中的constructor。<strong>如果替换了原型对象天，一定要重新为这个新原型添加constructor属性</strong></p>
<h3 id="五、动态原型模式"><a href="#五、动态原型模式" class="headerlink" title="五、动态原型模式"></a>五、动态原型模式</h3><h4 id="1、特点：-2"><a href="#1、特点：-2" class="headerlink" title="1、特点："></a>1、特点：</h4><p>1、把上面的组合方法进行了更好的封装。<br>2、不能使用字面量的方式重写原型了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.age=age;</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">"funciton"</span>)&#123;</div><div class="line">		Person.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"lee"</span>,<span class="number">24</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"li"</span>,<span class="number">18</span>);</div></pre></td></tr></table></figure></p>
<p>if判断保证创建多个实例时，只进行一次原型修改，把上面的组合方法进行了巧妙的封装。<br>若重写原型对象，实例的创建必须在原型对象修改完毕之后，不然会发生原型隔离（抛弃已定义原型的方法）。这里在创建person1实例时,还没执行到if时实例已经完成了[[prototype]]连接，也就是person1实例已经有了他的原型对象，这是在进行字面量修改原型是没有用的，所以只能使用原型.的方式进行属性方法添加。</p>
<h3 id="六、寄生构造函数模式"><a href="#六、寄生构造函数模式" class="headerlink" title="六、寄生构造函数模式"></a>六、寄生构造函数模式</h3><h4 id="1、特点：-3"><a href="#1、特点：-3" class="headerlink" title="1、特点："></a>1、特点：</h4><p>1、跟工厂模式一样，其实就是一个包装函数，在函数的内部创建对象、为其添加属性方法然后返回这个对象。<br>2、只是在把函数的创建放在函数中，跟在外面创建对象没有什么不同，不涉及构造函数的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">funciton Person(name,age)&#123;</div><div class="line">	<span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.name=name;</div><div class="line">	o.age=age;</div><div class="line">	o.intr=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">":"</span>+<span class="keyword">this</span>.age);</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、使用场景；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> values=<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	<span class="comment">//传参</span></div><div class="line">	values.push.apply(values,<span class="built_in">arguments</span>);</div><div class="line">	values.toPipedString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> values;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr1=<span class="keyword">new</span> SpecialArry(<span class="string">"lee"</span>,<span class="string">"li"</span>);</div><div class="line">arr1.toPipedString();<span class="comment">//"lee|"</span></div></pre></td></tr></table></figure></p>
<p>我想创建好多带有特殊方法的数组，又不能改变原生的Array构造函数这是就可以使用这个模式。</p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[label]]></title>
      <url>/blog/2017/07/24/label/</url>
      <content type="html"><![CDATA[<p>这篇主要记录在label标签上绑定事件会触发两次的一个bug，还有记录看到一个不错的label的样式。<a id="more"></a></p>
<h2 id="一、label触发两次的bug"><a href="#一、label触发两次的bug" class="headerlink" title="一、label触发两次的bug"></a>一、label触发两次的bug</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> id=<span class="string">"d2"</span> name=<span class="string">"age"</span>&gt;&lt;<span class="keyword">label</span> <span class="keyword">for</span>=<span class="string">"d2"</span>&gt;年龄&lt;/<span class="keyword">label</span>&gt;</div><div class="line">&lt;<span class="keyword">label</span>&gt;&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> name=<span class="string">"age"</span>&gt;年龄&lt;/<span class="keyword">label</span>&gt;</div></pre></td></tr></table></figure>
<p>上面两种方式都可以实现label的效果，第二种省略了id和for也是可以的，简化了代码。对于事件绑定来说，你只要两种方式都绑定在input上就没有什么问题。但是如果你需要绑定在lable上，对于<code>&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;age&quot;&gt;年龄&lt;/label&gt;</code>这种来说就会触发两次。<br>解释：label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。<strong>当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</strong>也就是，当label执行click事件时，那么它会传递给input再执行一次同一click事件，而且事件源对象都是label。</p>
<h2 id="二、一个不错的样式"><a href="#二、一个不错的样式" class="headerlink" title="二、一个不错的样式"></a>二、一个不错的样式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">label</span>&#123;</div><div class="line">	<span class="attribute">cursor</span>: pointer;</div><div class="line">	<span class="attribute">display</span>: inline-block;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">label</span> <span class="selector-tag">span</span>&#123;</div><div class="line">	<span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">   	<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(0,0,0,0.15);</div><div class="line">   	<span class="attribute">border-radius</span>: <span class="number">100%</span>;</div><div class="line">   	<span class="attribute">display</span>: inline-block;</div><div class="line">   	<span class="attribute">height</span>: <span class="number">16px</span>;</div><div class="line">   	<span class="attribute">margin-right</span>: <span class="number">10px</span>;</div><div class="line">   	<span class="attribute">margin-top</span>: -<span class="number">1px</span>;</div><div class="line">   	<span class="attribute">vertical-align</span>: middle;</div><div class="line">   	<span class="attribute">width</span>: <span class="number">16px</span>;</div><div class="line">   	<span class="attribute">line-height</span>: <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">label</span> <span class="selector-tag">input</span>&#123;</div><div class="line">	<span class="attribute">display</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">label</span> <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> +<span class="selector-tag">span</span><span class="selector-pseudo">:after</span>&#123;</div><div class="line">	<span class="attribute">background-color</span>: <span class="number">#cc80dd</span>;</div><div class="line">   	<span class="attribute">border-radius</span>: <span class="number">100%</span>;</div><div class="line">   	<span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">   	<span class="attribute">display</span>: inline-block;</div><div class="line">   	<span class="attribute">height</span>: <span class="number">12px</span>;</div><div class="line">   	<span class="attribute">margin</span>: <span class="number">2px</span>;</div><div class="line">   	<span class="attribute">width</span>: <span class="number">12px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果：<img src="/blog/myimages/label/p1.png" alt="展示效果"></p>
]]></content>
      
        <categories>
            
            <category> HTML </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[探究this]]></title>
      <url>/blog/2017/07/16/%E6%8E%A2%E7%A9%B6this/</url>
      <content type="html"><![CDATA[<p>此篇结合是我在看《你不知道的JavaScript》对this绑定的一些心得体会和记录。<a id="more"></a></p>
<h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h2><h3 id="一、默认绑定"><a href="#一、默认绑定" class="headerlink" title="一、默认绑定"></a>一、默认绑定</h3><p>独立函数调用，函数直接使用不带任何修饰的函数引用进行调用.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">defaultFn();<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>本例中（非严格模式）this指向全局对象。默认邦定在其他规则无法应用时的默认规则。</p>
<h3 id="二、隐式绑定"><a href="#二、隐式绑定" class="headerlink" title="二、隐式绑定"></a>二、隐式绑定</h3><p>必须在对象内部包含一个指向函数的函数，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unTypeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">	<span class="attr">foo</span>:unTypeFn</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">obj.foo();<span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>在obj对象中包含一个unTypeFn的引用，在通过obj调用unTypeFn时，this被自然的绑定到obj上，没毛病。</p>
<h4 id="1、隐式丢失"><a href="#1、隐式丢失" class="headerlink" title="1、隐式丢失"></a>1、隐式丢失</h4><p>this绑定的最常见问题就是隐式绑定的函数会丢失绑定对象，也就是会应用默认绑定，从而把this绑定在全局对象上（非严格模式）。</p>
<h5 id="1、值传递"><a href="#1、值传递" class="headerlink" title="1、值传递"></a>1、值传递</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unTypeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">	<span class="attr">foo</span>:unTypeFn</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line"><span class="comment">//引用类型传递</span></div><div class="line">va c=obj.foo;</div><div class="line">c();<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>obj.foo并没有直接调用，而是把它的引用地址传递给了c,所以c实际上引用的是unTypeFn函数本身，这里是默认绑定规则this指向全局。</p>
<h5 id="2、参数传递"><a href="#2、参数传递" class="headerlink" title="2、参数传递"></a>2、参数传递</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unTypeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFn</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">	fn();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">	<span class="attr">foo</span>:unTypeFn</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line"><span class="comment">//把obj.foo当做参数传递</span></div><div class="line">dofn(obj.foo);<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>参数传递和值传递类似,都不是直接调用obj.foo，而是把它当做值来传递。</p>
<h5 id="3、回调函数"><a href="#3、回调函数" class="headerlink" title="3、回调函数"></a>3、回调函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unTypeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">	<span class="attr">foo</span>:unTypeFn</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line"><span class="comment">//回调函数的例子</span></div><div class="line">setTimeout(obj.foo,<span class="number">1000</span>);<span class="comment">//2</span></div><div class="line">d1.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	obj.foo();</div><div class="line">&#125;,<span class="literal">false</span>);<span class="comment">//2</span></div><div class="line"><span class="comment">//绑定在DOM元素上了</span></div><div class="line">d1.addEventListener(<span class="string">"click"</span>,obj.foo,<span class="literal">false</span>);<span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>这两个都是回调函数的例子感觉跟上面的两个还是一回事，都不是立即调用，都是当做值来传递，这样会发生隐式邦定丢失。</p>
<h3 id="三、显式绑定"><a href="#三、显式绑定" class="headerlink" title="三、显式绑定"></a>三、显式绑定</h3><p>在某个对象上直接强制调用函数，使用js内部的call和apply方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1=&#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">2</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">typeFn.call(obj);<span class="comment">//1</span></div><div class="line"><span class="comment">//这里可以改变this绑定的对象</span></div><div class="line">typeFn.call(obj1);<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>call和apply方法是立即执行的，那么在多次调用这个方法是就可能改变this绑定的对象，于是就出现了显示绑定的变种——硬绑定的方法。</p>
<h4 id="1、硬绑定"><a href="#1、硬绑定" class="headerlink" title="1、硬绑定"></a>1、硬绑定</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeFn</span></span>()&#123;</div><div class="line">	console.log(<span class="built_in">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">	a:<span class="type">1</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1=&#123;</div><div class="line">	a:<span class="type">2</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">1</span>=typeFn.bind(obj);</div><div class="line"><span class="keyword">new</span><span class="type">1</span>();<span class="comment">//1</span></div><div class="line"><span class="comment">//之后你就可以尽情的操作new1了，都不会改变typeFn绑定在obj上的事实</span></div><div class="line"><span class="keyword">new</span><span class="type">1</span>.bind(obj1);</div><div class="line"><span class="keyword">new</span><span class="type">1</span>();<span class="comment">//1</span></div><div class="line"><span class="keyword">new</span><span class="type">1</span>.call(obj1)<span class="comment">//1;</span></div></pre></td></tr></table></figure>
<p>ES5提供里内置的bind方法，返回一个新的绑定你指定this的函数，可以方便的进行硬绑定。new1.bind(obj).bind(obj1)是没啥用的他只会执行第一个。</p>
<h3 id="四、new绑定"><a href="#四、new绑定" class="headerlink" title="四、new绑定"></a>四、new绑定</h3><p>//待议</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3>]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[web存储机制]]></title>
      <url>/blog/2017/07/13/web%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>HTML5提供了两种客户端存储数据的新方法:<br>1、localStorage-没有时间限制的数据存储<br>2、sessionStorage-针对一个session（一个标签页）的数据存储。<br>这篇文章主要介绍这两个新方法和对比俩个方法的不同，和一些实际的应用<a id="more"></a></p>
<h2 id="一、localStorage"><a href="#一、localStorage" class="headerlink" title="一、localStorage"></a>一、localStorage</h2><h3 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a>1、说明</h3><p>localStorage即本地储存，可以长久保存整个网站的数据，保存的数据没有过期时间，直到手动清除。</p>
<h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><p>（1）同源策略限制。在同一协议、同一主机名和同一端口下的所有页面都可以访问通过localStorage存储的数据。<br>（2）在本地浏览器储存，不会涉及到服务器。<br>（3）永久保存。数据没有过期时间，直到手动清除（浏览器清缓存也不行）。<br>（4）储存方式。采用key,value的方式，而且value的值必学是string类型（传入其他类型会转化为string类型）。<br>（5）不同浏览器不能相互访问。</p>
<h3 id="3、使用场景"><a href="#3、使用场景" class="headerlink" title="3、使用场景"></a>3、使用场景</h3><p>1、多页面访问相同数据。2、数据较大时的临时储存。</p>
<h2 id="二、sessionStorage"><a href="#二、sessionStorage" class="headerlink" title="二、sessionStorage"></a>二、sessionStorage</h2><h3 id="1、说明-1"><a href="#1、说明-1" class="headerlink" title="1、说明"></a>1、说明</h3><p>sessionStorage用于保存一个窗口或标签页的数据，关闭之后数据会被清除。</p>
<h3 id="2、特点-1"><a href="#2、特点-1" class="headerlink" title="2、特点"></a>2、特点</h3><p>（1）单标签页限制。sessionStorage操作限制在单标签页(仅指顶层标签页)中，不在一个标签页中无法访问数据，这也是它和localStorage的区别之一。<br>（2）在本地浏览器储存，不会涉及到服务器。<br>（3）储存方式。采用key,value的方式，而且value的值必学是string类型（传入其他类型会转化为string类型）。<br>（4）关闭窗口或标签页数据清空。<br>（5）同一顶级标签页下的不同页面（只要不是通过下面方法打开的）在打开是可以访问顶级标签页的数据，但也就是这是能联系，之后他们之间不会有任何关联。<br>（6）不同浏览器不能相互访问。</p>
<h3 id="3、使用场景-1"><a href="#3、使用场景-1" class="headerlink" title="3、使用场景"></a>3、使用场景</h3><p>sessionStorage就是用在单页面应用中使用。</p>
<h4 id="单标签页解释。"><a href="#单标签页解释。" class="headerlink" title="单标签页解释。"></a>单标签页解释。</h4><p>这里的标签页是指顶层标签页，即从顶层通过链接打开的新页面（新页面下面的页面）都算是这个标签页中的。<br>浏览器新标签（顶层）的打开方式：<br>  1、输入网址打开。<br>  2、右键打开新标签页。<br>  3、f12 open in new tab。<br>这些都算是打开一个新的顶层标签页，这些新的标签页通过sessionStorage储存的数据不共享。这种单标签页限制区别于localStorage。  </p>
<h2 id="三、storage事件"><a href="#三、storage事件" class="headerlink" title="三、storage事件"></a>三、storage事件</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>无论是对sessionStorage还是localStorage进行操作，只要是对storage对象进行任何修改都会触发storage事件。</p>
<h3 id="2、限制"><a href="#2、限制" class="headerlink" title="2、限制"></a>2、限制</h3><p>1、目前chrome并不支持在当前页触发，只能检测同源页面，单页面应用就gg了。<br>2、目前chrome重复载入相同数据也不触发，监听事件时要小心，不要怀疑世界了。<br>例如：我现在有同源的A和B两个页面，使用chrome改变A的localStorage，B页面会触发onstorage事件，但是A页面并不会触发。在A页面设置<code>localStorage.timeCout=5</code>，再次<code>localStorage.timeCout=5</code>,B页面不会触发。</p>
<h3 id="2、改进方法"><a href="#2、改进方法" class="headerlink" title="2、改进方法"></a>2、改进方法</h3><h4 id="1、重写setItem方法。"><a href="#1、重写setItem方法。" class="headerlink" title="1、重写setItem方法。"></a>1、重写setItem方法。</h4><p>localStorage.setItem(“name”,”Li”);这样和localStorage.name（对象点方法）相同的，所以我们就可以重写一下setItem方法，在页面调用setItem时就可以在本页面检测到这个事件啦。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在替换之前记录一下,给下面使用</span></div><div class="line"><span class="keyword">var</span> SetItem=localStorage.setItem;</div><div class="line">localStorage.setItem=<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</div><div class="line">	<span class="comment">//创建事件对象</span></div><div class="line">	<span class="keyword">var</span> setItemEvent=<span class="keyword">new</span> Event(<span class="string">"setItemEvent"</span>);</div><div class="line">	setItemEvent.value=value;</div><div class="line">	setItemEvent.key=key;</div><div class="line">	<span class="comment">//手动触发setItemEvent事件</span></div><div class="line">	<span class="built_in">window</span>.dispatchEvent(setItemEvent);</div><div class="line">	<span class="comment">//执行原方法，是还没重写之前的，这里的this指Storage。</span></div><div class="line">	SetItem.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"setItemEvent"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(e.key=<span class="string">"xx"</span>)&#123;</div><div class="line">		<span class="built_in">console</span>.log(e.value);</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>注：方法里的SetItem.apply(this,arguments)把SetItem方法绑定到Storage对象上，这样才能执行，要是SetItem()报Uncaught TypeError: Illegal invocation这个错。SetItem()相当于把这个Storage对象的setItem方法绑定到window上执行，是不行的。举个例子:<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d=<span class="built_in">document</span>.getElementById;</div><div class="line"><span class="keyword">var</span> c=d(<span class="string">"d1"</span>);</div><div class="line"><span class="comment">//报错：Uncaught TypeError: Illegal invocation。未捕获的类型错误：非法调用</span></div></pre></td></tr></table></figure></p>
<p>其实就是这样<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d=<span class="built_in">document</span>.getElementById;</div><div class="line"><span class="keyword">var</span> c=d.call(<span class="built_in">window</span>,<span class="string">"d1"</span>);</div></pre></td></tr></table></figure></p>
<p>d1的DOM元素应该在document对象中，你非得给人绑定到window对象中肯定是不合适的。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d=<span class="built_in">document</span>.getElementById;</div><div class="line"><span class="keyword">var</span> c=d.call(<span class="built_in">document</span>,<span class="string">"d1"</span>);</div></pre></td></tr></table></figure></p>
<p>这样你在试试</p>
<h4 id="2、添加数据变的作为事件监听"><a href="#2、添加数据变的作为事件监听" class="headerlink" title="2、添加数据变的作为事件监听"></a>2、添加数据变的作为事件监听</h4><p>例如：你想获取每次count的值，但是这个count的变化又是没有规律的（有时变有时不变），对于chrome来说重复载入相同数据不会触发事件，就会很尴尬。那么你就可以在每次改变count之后再添加一个每次都变好的change数据，这样你就可以通过监听change来获取每次count的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	localStorage.count=<span class="number">3</span>；</div><div class="line">	localStorage.change=+<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">&#125;</div><div class="line"><span class="comment">/*监听事件*/</span></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"storage"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(e.key==<span class="string">"change"</span>)&#123;</div><div class="line">           <span class="keyword">var</span> count=localStorage.count;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<h2 id="四、localstorage应用实例"><a href="#四、localstorage应用实例" class="headerlink" title="四、localstorage应用实例"></a>四、localstorage应用实例</h2><h3 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h3><p>这段事件在做一个在线教育项目，有一个检测学生在线是否偷懒的功能。因为网站和后台的交互比较多所以就记录用户最新发送ajax请求的时间，再用计时器不断轮询这个时间看是否大于规定时间来判断孩子是否偷懒。</p>
<h3 id="2、难点"><a href="#2、难点" class="headerlink" title="2、难点"></a>2、难点</h3><p>1、要是这个时间记录在后台那么我们就要不断到后台请求这个时间这肯定是不合理的。<br>2、要在浏览器端实现多页面间的数据共享。<br>3、实现多个页面之间的计时器同步（假如两个页面的计时器差3s,那么这两个页面检测偷懒提示就会差3s）。<br>4、一个页面的提示关闭，所有页面的提示都要关闭。</p>
<h3 id="3、解决方法"><a href="#3、解决方法" class="headerlink" title="3、解决方法"></a>3、解决方法</h3><p>1、使用localStorage实现浏览器端的数据存储，减少服务器压力。<br>2、localStorage实现数据共享。<br>3、用storage事件检测不同页面间的localStorage数据变化，实现不同页面间的计时器同步<br>4、重写localStorage.setItem方法，实现单页面检测localStorage数据变化，实现计时器同步。<br>5、利用Storage间接监听提示关闭事件。</p>
<h3 id="4、代码"><a href="#4、代码" class="headerlink" title="4、代码"></a>4、代码</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">on</span> <span class="keyword">the</span> way</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[函数节流]]></title>
      <url>/blog/2017/07/12/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>DOM操作比起非DOM操作需要更多的内存和cpu时间，连续事件内进行多次的DOM操作可能会导致浏览器挂起或崩溃。例如resize,mousemove,scroll,keydown,keyup（打字时）等事件。这时便可以使用函数节流来介绍DOM操作，此篇主要介绍了函数节流的思想和方法。<a id="more"></a></p>
<h2 id="一、函数节流思想原理"><a href="#一、函数节流思想原理" class="headerlink" title="一、函数节流思想原理"></a>一、函数节流思想原理</h2><h3 id="1、思想"><a href="#1、思想" class="headerlink" title="1、思想"></a>1、思想</h3><p>函数节流的基本思想是，某些操作不能在没有间断的情况下连续重复执行。</p>
<h3 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h3><p>第一次调用时创建一个一次性定时器，在指定延迟时间后执行代码。第二次调用时，清空这个定时器重新创建一个新的计时器。如果前一个计时器执行完毕，没有什么关系，但是如果前一个计时器尚未执行，那个就会用新的计时器代替，时间从零开始。</p>
<h3 id="3、方法"><a href="#3、方法" class="headerlink" title="3、方法"></a>3、方法</h3><p>在《javascript高级程序设计》一书中有专门关于函数节流的介绍，下面是它的几个方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> processor=&#123;</div><div class="line">	<span class="attr">timeoutId</span>:<span class="literal">null</span>,</div><div class="line">	<span class="comment">//实际的操作</span></div><div class="line">	method:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="number">666</span>);</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">//需要进行的初始化操作</span></div><div class="line">	process:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		clearTimeout(<span class="keyword">this</span>.timeoutId);</div><div class="line">		<span class="keyword">var</span> that=<span class="keyword">this</span>;</div><div class="line">		<span class="keyword">this</span>.timeoutId=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			that.method();</div><div class="line">		&#125;,<span class="number">100</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用</span></div><div class="line"><span class="built_in">window</span>.onresize=processor.process();</div></pre></td></tr></table></figure></p>
<p>这个把实际操作的方法和函数节流方法封装成一个对象，看起来麻烦一点。在计时器中函数的执行环境是window，这里用that储存执行环境。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(</span><span class="function"><span class="keyword">method</span>,<span class="title">time</span>,<span class="title">context</span>)&#123;</span></div><div class="line">	clearTimeout(<span class="function"><span class="keyword">method</span>.<span class="title">timeoutId</span>);</span></div><div class="line">	<span class="function"><span class="keyword">method</span>.<span class="title">timeoutId</span>=</span>setTimeout(<span class="function"><span class="keyword">function</span>(</span>)&#123;</div><div class="line">		<span class="function"><span class="keyword">method</span>.<span class="title">call</span>(</span>context);</div><div class="line">	&#125;,time);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">haha</span>(</span>)&#123;</div><div class="line">	console.<span class="built_in">log</span>(<span class="number">666</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用</div><div class="line">window.onresize=<span class="function"><span class="keyword">function</span>(</span>)&#123;</div><div class="line">	throttle(haha,<span class="number">100</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个也是用的计时器和上面的原理相同只是做了简化，把timeoutId作为函数的变量储存。三个参数分别是：{method:要执行的操作,time:在多长时间内不能重复执行，context:执行环境}，省略第三个参数在全局执行。</p>
<h3 id="4、升级版"><a href="#4、升级版" class="headerlink" title="4、升级版"></a>4、升级版</h3><p>这些方法也是有不足之处的，例如你想页面滚动加载，那你一直滚动就会重复更新计时器，那页面加载事件岂不是执行不了吗。随意在网上看到一个升级版节流函数，觉得很好就mark一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method,time,mustRunTime</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> time=<span class="literal">null</span>;</div><div class="line">	<span class="keyword">var</span> t_start;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> context=<span class="keyword">this</span>,args=<span class="built_in">arguments</span>,t_curr=+<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">		clearTimeout(thimer);</div><div class="line">		<span class="comment">//第一次执行</span></div><div class="line">		<span class="keyword">if</span>(!t_start)&#123;</div><div class="line">			t_start=t_curr;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(t_curr-t_start&gt;=mustRunTime)&#123;</div><div class="line">			<span class="comment">//时间超过最大限制时间，执行一次</span></div><div class="line">			method.apply(context,args);</div><div class="line">			t_start=t_curr;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			timer=setTimeout(funciton()&#123;</div><div class="line">				method.apply(context,args);</div><div class="line">			&#125;,time);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">haha</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">666</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用</span></div><div class="line"><span class="built_in">window</span>.onresize=throttle(haha,<span class="number">60</span>,<span class="number">100</span>);</div></pre></td></tr></table></figure></p>
<p><code>throttle(haha,60,100)</code>意思是60ms内重复操作不执行，超过100ms必须执行一次。这个方法加入了一个最大时间判断，在进行优化程序的同时尽量解决用户体验。</p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[一元运算符]]></title>
      <url>/blog/2017/07/07/%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>最近看到一个+new Date()的语法方式，就顺便研究了一下一元运算符，此篇主要介绍了一元运算符。<a id="more"></a></p>
<h2 id="一、-运算符"><a href="#一、-运算符" class="headerlink" title="一、+-运算符"></a>一、+-运算符</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、+"></a>1、+</h3><p>那就从+new Date()语法开始，其实这里并没有什么高级语法，只是+会把后面的内容变为number类型（对数字无效）。这里的<code>+new Date()=Number(new Date())</code>。<code>console.log(typeof(+new Date()));</code>得到number类型。<br>这里比较奇怪的是new Date()对象竟然可以成功转为number类型，以后再也不用get.time()方法了。</p>
<h3 id="2、"><a href="#2、" class="headerlink" title="2、-"></a>2、-</h3><p>减法跟加法一致，都是把后面的内容变为数字，只不过还会对该值求负。和上面一样如果转不了就返回NaN也符合Number()的特征。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sNum = <span class="string">"20"</span>;</div><div class="line">alert(<span class="keyword">typeof</span> sNum);	<span class="comment">//输出 "string"</span></div><div class="line"><span class="keyword">var</span> iNum = -sNum;</div><div class="line">alert(iNum);		<span class="comment">//输出 "-20"</span></div><div class="line">alert(<span class="keyword">typeof</span> iNum);	<span class="comment">//输出 "number"</span></div></pre></td></tr></table></figure></p>
<h2 id="二、-a和a"><a href="#二、-a和a" class="headerlink" title="二、++a和a++"></a>二、++a和a++</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(++a);<span class="comment">//输出4</span></div><div class="line"><span class="keyword">var</span> b=<span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(b++);<span class="comment">//输出3</span></div></pre></td></tr></table></figure>
<p>这个就是“先执行再运算”和“先运算再执行”，其实也好记，加号在前边就是先加自己在管其他。</p>
<h2 id="三、void、delete"><a href="#三、void、delete" class="headerlink" title="三、void、delete"></a>三、void、delete</h2><h3 id="1、delete"><a href="#1、delete" class="headerlink" title="1、delete"></a>1、delete</h3><p>delete运算符可以将自定义的属性和方法删除：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</div><div class="line">o.name = <span class="string">"David"</span>;</div><div class="line">alert(o.name);	<span class="comment">//输出 "David"</span></div><div class="line"><span class="keyword">delete</span> o.name;</div><div class="line">alert(o.name);	<span class="comment">//输出 "undefined"</span></div></pre></td></tr></table></figure></p>
<p>此运算符在发生原型遮蔽时删除属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Person.prototype.name=<span class="string">"Lee"</span>;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</div><div class="line">person1.name=<span class="string">"James"</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//James</span></div><div class="line"><span class="comment">//这里不论是怎样赋值name(null或"")都只会在person1这个实例中修改，</span></div><div class="line"><span class="comment">//原型的方法还是会被遮蔽。这时delete方法的作用就体现出来了。</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person1.name;</div><div class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//Lee</span></div></pre></td></tr></table></figure></p>
<p>同时我们也发现，对于Javascript内置的属性和方法是不行的:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> o.<span class="built_in">toString</span>;//报错</div></pre></td></tr></table></figure></p>
<p>toString()是JavaScript原生方法。</p>
<h3 id="2、void"><a href="#2、void" class="headerlink" title="2、void"></a>2、void</h3><p>void 运算符对任何值返回 undefined。该运算符通常用于避免输出不应该输出的值。例如<code>&lt;a href=&quot;javascript:void(back())&quot;&gt;</code>这里点击a即执行了back事件，有避免了页面跳转。</p>
]]></content>
      
        <categories>
            
            <category> Javascript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[console打印dom对象]]></title>
      <url>/blog/2017/07/07/console%E6%89%93%E5%8D%B0dom%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>在操作dom时，可能会需要在控制台查看Dom对象的属性方法（比差文档快多了），本篇就介绍了这样的方法<a id="more"></a></p>
<h2 id="一、原生和jqDom对象console对比"><a href="#一、原生和jqDom对象console对比" class="headerlink" title="一、原生和jqDom对象console对比"></a>一、原生和jqDom对象console对比</h2><p>我们想要获得原生Dom的属性方法，像这样：<br><img src="/blog/myimages/consoleDom/p1.png" alt="打印的Dom详细"><br>这里可以看到一切。我们知道jquery是很好在控制台输出的，只要有$(“”)选择器查找到元素console一下就会得到：<br><img src="/blog/myimages/consoleDom/p2.png" alt="打印的jqDom"><br>0的位置是htmlDom,但是下面的方法就是jq的方法了。很简单可以自己试一下。<br>但是正题来了怎样才能在控制台console原生Dom对象呢？</p>
<h2 id="二、在控制台输出原生对象的方法"><a href="#二、在控制台输出原生对象的方法" class="headerlink" title="二、在控制台输出原生对象的方法"></a>二、在控制台输出原生对象的方法</h2><pre><code>&lt;div id=&quot;d1&quot;&gt;&lt;div id=&quot;d2&quot;&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;

var d1=document.getElementById(&quot;d1&quot;);
var d2=document.getElementById(&quot;d2&quot;);

console.log(d1.childNodes); //Dom 对象
console.log(d1.firstChild); //文本
console.log(d1.lastChild);  //文本
console.log(d2.parentNode); //文本
console.log(d2.nextSibling);//文本
</code></pre><p>不要怀疑上面的都是对象(不信typeof一下)，只是浏览器的控制台输出策略不同。<br>测试结果：用选择器选的只能输出文本，只有一个childNodes可以输出对象。这是chrome浏览器，但是火狐就比较厉害了无论用什么找到的都能输出对象。当然你也不可能在专门为了看属性在打开一个火狐浏览器（用火狐开发的当没看到）。下面就介绍chrome的输出对象的方法：<br>当当当，就是全部<strong>封装成Array</strong>的形式。 <code>console.log([d1.lastChild])</code>这样你就可以得到输出的dom对象了还可以得到Array的方法属性奥，似不似很厉害啊。<br><img src="/blog/myimages/consoleDom/p4.png" alt="打印的jqDom">  </p>
]]></content>
      
        <categories>
            
            <category> 调试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[console.log一个奇怪的问题]]></title>
      <url>/blog/2017/07/01/console/</url>
      <content type="html"><![CDATA[<p>最近遇到一个关于console.log奇怪的问题，搞得我是百思不得其解，写出来做一下记录:<br><a id="more"></a><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a=&#123;<span class="built_in">name</span>:<span class="number">1</span>&#125;;</div><div class="line">console.<span class="built_in">log</span>(a);</div><div class="line">a.<span class="built_in">name</span>=<span class="number">2</span>;</div><div class="line">console.<span class="built_in">log</span>(a);</div></pre></td></tr></table></figure></p>
<p>结果显而易见是name:1;name:2啊，但打开控制台，呵呵：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span> </div><div class="line">	name: <span class="string">"2"</span></div><div class="line">	__proto__: <span class="built_in">Object</span></div><div class="line"><span class="built_in">Object</span></div><div class="line">	name: <span class="string">"2"</span></div><div class="line">	__proto__: <span class="built_in">Object</span></div></pre></td></tr></table></figure></p>
<p>完了感觉自己白学js了，当我抱着怀疑人生的态度刷新了一遍浏览器之后，终于见到我想见的答案了：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span> </div><div class="line">	name: <span class="string">"1"</span></div><div class="line">	__proto__: <span class="built_in">Object</span></div><div class="line"><span class="built_in">Object</span></div><div class="line">	name: <span class="string">"2"</span></div><div class="line">	__proto__: <span class="built_in">Object</span></div></pre></td></tr></table></figure>
<p>之所以会出现这样的结果是因为<strong>代码在运行的时候控制台并没有打开</strong>。<br>console并不是JavaScript的对象，而是浏览器提供的方法，只有当你打开控制台是它才生效，所以当你打开网页代码执行完毕之后,console.log并没有执行，而是等到你打开控制台之后才会执行，这时的a早已经不是原来的单纯的a了。也就是相当于这样的执行顺序：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;<span class="built_in">name</span>: <span class="string">'1'</span>&#125;;</div><div class="line">a.<span class="built_in">name</span> = <span class="string">'2'</span>;</div><div class="line">console.<span class="built_in">log</span>(a);</div><div class="line">console.<span class="built_in">log</span>(a);</div></pre></td></tr></table></figure></p>
<p>而你在打开控制台之后再刷新页面得到的也就是之前正常的顺序了。<br>感觉浏览器厂商这么做也是有一定道理的，既然你console.log了肯定是要打开控制台调试的嘛，你不打开控制台看那我也就不执行多余的console操作了，节省了内存。</p>
<p>最后还有一个问题没有解决：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"page"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="keyword">var</span> a=<span class="built_in">document</span>.getElementById(<span class="string">"page"</span>);</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"span"</span>));</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line">得到结果：</div><div class="line">&lt;div id=<span class="string">"page"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&lt;div id=<span class="string">"page"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>放心js是顺序执行的，但是无论我怎么刷新页面结果都是一样的，这就尴尬了。等待之后有机会在探讨吧，有哪位大神指导一下是最好的啦。</p>
]]></content>
      
        <categories>
            
            <category> 调试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Pagination分页增加页面跳转功能]]></title>
      <url>/blog/2017/05/26/pagination/</url>
      <content type="html"><![CDATA[<p>Pagination是JQuery一款十分经典的分页插件，我在之前的基础上做了一点很小的改动：1、增加了页码输入跳转的功能，可以自己决定是否出现此功能。2、增加一个点击事件函数，返回点击的页码，可以实现ajax分次请求<a id="more"></a>  </p>
<p><a href="http://oljtqy7i8.bkt.clouddn.com/pagination.zip" title="js和css源码" target="_blank" rel="external">Pagination源码下载</a></p>
<h2 id="一、pagination使用方法"><a href="#一、pagination使用方法" class="headerlink" title="一、pagination使用方法"></a>一、pagination使用方法</h2><h3 id="1、使用方法"><a href="#1、使用方法" class="headerlink" title="1、使用方法"></a>1、使用方法</h3><p>跟一般的jQuery插件一样，此插件需要引入jq,使用也很简单便捷。方法是pagination，例如<code>$(&quot;#page&quot;).pagination(100);</code>，这里的100参数是必须的，表示显示项目的总个数，这是最简单的使用，得到的显示如下：<br><img src="/blog/myimages/pagination/p1.png" alt="展示效果"></p>
<h3 id="2、参数详解"><a href="#2、参数详解" class="headerlink" title="2、参数详解"></a>2、参数详解</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">这是参数的默认值，可以自行修改</div><div class="line">&#123;</div><div class="line"><span class="symbol">    items_per_page:</span><span class="number">10</span>,<span class="comment">//每页数目</span></div><div class="line"><span class="symbol">    num_display_entries:</span><span class="number">10</span>,<span class="comment">//中间数目</span></div><div class="line"><span class="symbol">    current_page:</span><span class="number">0</span>,<span class="comment">//当前页数</span></div><div class="line"><span class="symbol">    num_edge_entries:</span><span class="number">0</span>,<span class="comment">//边缘数目</span></div><div class="line"><span class="symbol">    link_to:</span><span class="string">"#"</span>,</div><div class="line"><span class="symbol">    prev_text:</span><span class="string">"Prev"</span>,</div><div class="line"><span class="symbol">    next_text:</span><span class="string">"Next"</span>,</div><div class="line"><span class="symbol">    ellipse_text:</span><span class="string">"..."</span>,<span class="comment">//中间多想代替文字</span></div><div class="line"><span class="symbol">    prev_show_always:</span>true,<span class="comment">//上一页是否展示</span></div><div class="line"><span class="symbol">    next_show_always:</span>true,<span class="comment">//下一个页是否展示</span></div><div class="line"><span class="symbol">    ifGo:</span>false,<span class="comment">//决定是否出现跳转功能</span></div><div class="line"><span class="symbol">    ifGo_text:</span><span class="string">"Go"</span>,<span class="comment">//跳转到文字</span></div><div class="line"><span class="symbol">    a_fn:</span>function()&#123;return false;&#125;,<span class="comment">//每次单击的触发的事件（返回页码，可以ajax请求）</span></div><div class="line"><span class="symbol">    callback:</span>function()&#123;return false;&#125;<span class="comment">//每次单击的回调函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、使用举例"><a href="#3、使用举例" class="headerlink" title="3、使用举例"></a>3、使用举例</h3><h4 id="1、原版"><a href="#1、原版" class="headerlink" title="1、原版"></a>1、原版</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"page"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"pagination"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">$(<span class="string">"#Pagination"</span>).pagination(<span class="number">56</span>, &#123;</div><div class="line">    <span class="attr">num_edge_entries</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">num_display_entries</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">callback</span>: pageselectCallback,</div><div class="line">    <span class="attr">items_per_page</span>:<span class="number">1</span>，</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>效果：<br><img src="/blog/myimages/pagination/p2.png" alt="展示效果"><br>这段代码表示的含义是：总共有56(maxentries)个列表项，首尾两侧分页显示2(num_edge_entries)个，连续分页主体数目显示4(num_display_entries)个，回调函数为pageselectCallback(callback)，每页显示的列表项为1(items_per_page)。您可以对照参数表修改配置这里的参数。</p>
<h4 id="2、页码输入跳转版"><a href="#2、页码输入跳转版" class="headerlink" title="2、页码输入跳转版"></a>2、页码输入跳转版</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;div id="page" class="pagination"&gt;</span><span class="params">&lt;/div&gt;</span></div><div class="line">$(<span class="string">"#Pagination"</span>).pagination(<span class="number">56</span>, &#123;</div><div class="line"><span class="symbol">    num_edge_entries:</span> <span class="number">2</span>,</div><div class="line"><span class="symbol">    num_display_entries:</span> <span class="number">4</span>,</div><div class="line"><span class="symbol">    callback:</span> pageselectCallback,</div><div class="line"><span class="symbol">    items_per_page:</span><span class="number">1</span>，</div><div class="line"><span class="symbol">    ifGo:</span><span class="number">10</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>效果：<br><img src="/blog/myimages/pagination/p3.png" alt="展示效果"><br>这段代码相对于上面多了一个ifGo：10，含义是只要分页超过10页就会出现输入跳转功能，可以点击Go和键盘enter跳转，默认是不显示。</p>
<h4 id="3、实现ajax分页请求"><a href="#3、实现ajax分页请求" class="headerlink" title="3、实现ajax分页请求"></a>3、实现ajax分页请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"page"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"pagination"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">$(<span class="string">"#Pagination"</span>).pagination(<span class="number">56</span>, &#123;</div><div class="line">    <span class="attr">num_edge_entries</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">num_display_entries</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">a_fn</span>: getpage,</div><div class="line">    <span class="attr">callback</span>: pageselectCallback,</div><div class="line">    <span class="attr">items_per_page</span>:<span class="number">1</span>，</div><div class="line">    ifGo:<span class="number">10</span></div><div class="line">&#125;);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getpage</span>(<span class="params">page_index</span>)</span>&#123;</div><div class="line">    <span class="comment">//这里可以发送ajax请求，请求点击页的数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意点：这里a_fn不能和获取56的函数共用一个，函数内容相同的情况也不能（要重写一个不包括pagination初始化的）。如果共用一个就会每次分页切换时都要重新加载一遍pagination造成浪费。当然新加一个全局变量保证在切换页码时不再加载pagination限制一下也是可以的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">if</span>First=<span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">if</span>First)&#123;</div><div class="line">    $(<span class="string">"#Pagination"</span>.pagination(56));</div><div class="line">    <span class="keyword">if</span>First=<span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="二、paginationJS跳转功能实现"><a href="#二、paginationJS跳转功能实现" class="headerlink" title="二、paginationJS跳转功能实现"></a>二、paginationJS跳转功能实现</h2><h3 id="1、获取用户输入数字方法"><a href="#1、获取用户输入数字方法" class="headerlink" title="1、获取用户输入数字方法"></a>1、获取用户输入数字方法</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function goNum()&#123;</div><div class="line">            <span class="keyword">var</span> np = numPages();</div><div class="line">            <span class="keyword">var</span> <span class="built_in">num</span>=Number(jQuery(<span class="string">".input_num"</span>).val());</div><div class="line">            <span class="comment">//判断用户输入有效值，并且不是当前页</span></div><div class="line">            <span class="keyword">if</span>(<span class="built_in">num</span>&amp;&amp;current_page!=<span class="built_in">num</span><span class="number">-1</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="built_in">num</span>&gt;=np)&#123;</div><div class="line">                    page_id=np<span class="number">-1</span>;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">num</span>&lt;=<span class="number">1</span>)&#123;</div><div class="line">                    page_id=<span class="number">0</span>;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    page_id=<span class="built_in">num</span><span class="number">-1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//取得输入的数字调用pageSelected;</span></div><div class="line">                pageSelected(page_id,<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>此方法用来获取用户输入的数字，并对数字有效性进行判断。若输入的数字大于最大分页数则跳转最后一页;若小于1则跳转到第一页;若不是number则不作反应。</p>
<h3 id="2、绑定键盘事件函数"><a href="#2、绑定键盘事件函数" class="headerlink" title="2、绑定键盘事件函数"></a>2、绑定键盘事件函数</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">keybind</span><span class="params">(e)</span></span>&#123;</div><div class="line">            <span class="keyword">var</span> code=e.keyCode;</div><div class="line">            <span class="keyword">if</span>(code==(<span class="number">13</span>||<span class="number">108</span>))&#123;</div><div class="line">                goNum();</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h3 id="3、判断是否添加跳转功能"><a href="#3、判断是否添加跳转功能" class="headerlink" title="3、判断是否添加跳转功能"></a>3、判断是否添加跳转功能</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*新加，判断是否添加go按钮*/</span></div><div class="line"><span class="keyword">if</span>(opts.ifGo&amp;&amp;<span class="built_in">np</span>&gt;=opts.ifGo)&#123;</div><div class="line">    <span class="built_in">var</span> inp=jQuery(<span class="string">"&lt;input class='input_num' type='text'/&gt;"</span>).bind(<span class="string">"keydown"</span>,keybind);</div><div class="line">    <span class="built_in">var</span> <span class="built_in">go</span>=jQuery(<span class="string">"&lt;span class='go'&gt;"</span>+opts.ifGo_text+<span class="string">"&lt;/span&gt;"</span>).bind(<span class="string">"click"</span>,goNum);</div><div class="line">    panel.<span class="built_in">append</span>(inp,<span class="built_in">go</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在drawlink主函数中添加判断是否绘制跳转按钮，条件是分页总数必须大于你设定的ifGo的值。若大于则创建input和go并绑定相应事件。</p>
<h3 id="4、css修改"><a href="#4、css修改" class="headerlink" title="4、css修改"></a>4、css修改</h3><p>下载资源中包括了css文件，你可以随心所欲修改你的css样式。  </p>
<h2 id="三、知识点"><a href="#三、知识点" class="headerlink" title="三、知识点"></a>三、知识点</h2><h3 id="1、js是值传递但是基本类型和引用类型表现不同。"><a href="#1、js是值传递但是基本类型和引用类型表现不同。" class="headerlink" title="1、js是值传递但是基本类型和引用类型表现不同。"></a>1、<strong>js是值传递但是基本类型和引用类型表现不同。</strong></h3><p>来上代码：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a=<span class="keyword">b=&#123;page:1&#125;;</span></div><div class="line"><span class="keyword">b.page=3;</span></div><div class="line">console.log(a)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>结果是page:3。上边a、b、包括后面的对象的地址都是指向堆中的同一个obj，所以b改变了a相应也会改变，同理上面的pannel和jq对象的引用相同panner改变this也会跟着改变。<br>强化理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    obj.name=<span class="string">"小明"</span>;</div><div class="line">    obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name=<span class="string">"小刚"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line"><span class="built_in">console</span>.log(person.name)</div></pre></td></tr></table></figure></p>
<p>结果：小明。首先创建一个person对象，person的地址就指向堆中一个object，调用setName是复制了person的地址给了obj，现在他们俩共同指向同一个object，于是改了obj的就相当于改了person的;接下来这个obj始乱终弃有指向了新的object2，也就和person再无任何瓜葛，他自己怎么玩是他自己的事情。所以最终结果是小明。  </p>
<h3 id="2、注：dom元素和jq对象都是对象。"><a href="#2、注：dom元素和jq对象都是对象。" class="headerlink" title="2、注：dom元素和jq对象都是对象。"></a>2、注：dom元素和jq对象都是对象。</h3><p>$(“div”):这个类似于一个构造函数，把dom元素封装起来并添加相应jq的方法。dom元素可以直接影响这个新对象，但是这个对象不能影响dom元素（针对这个对象的操作，例如添加name方法）。<br><code>document.getElementById()</code>之类的：这是个选择器，他直接指向dom元素，dom和它相互影响。</p>
<p>typeof用于检测简单类型(具体说他是确定一个变量是字符串、数值、布尔值、还是undefined的最佳工具，注：null返回object),返回一个字符串。  </p>
<p>对于对象，我们更想知道的是什么类型的对象。所以引进了instanceof操作符。  </p>
<p>person instanceof Object 这样来检测person是不是Object。  </p>
<p>person instanceof Array 这样来检测person是不是Array。  </p>
<h3 id="3、关于回调函数。"><a href="#3、关于回调函数。" class="headerlink" title="3、关于回调函数。"></a>3、关于回调函数。</h3><p>回调函数的意思就是在函数执行完毕调用的函数，而在这里使用参数的形式来设置回调函数，灵活性搞，可以任意设置回调函数。<br>pagination的回调函数的作用是显示对应分页的列表项内容,回调函数在用户每次点击分页链接的时候执行。<br>注意点：这里pagination的回调函数在分页创建时就调用了一次。</p>
]]></content>
      
        <categories>
            
            <category> Jquery </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JQ的四种绑定方式]]></title>
      <url>/blog/2017/04/28/jq%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="一、bind-unbind方法"><a href="#一、bind-unbind方法" class="headerlink" title="一、bind unbind方法"></a>一、bind unbind方法</h2><p>bind的特点就是会把监听器绑定到目标元素上，有几个事件就绑定几个，它和<code>$(selector).click(function)</code>是一样的。既然是绑定在目标元素上，也就是这个目标元素在绑定此事件的js执行完时，必须存在于页面上，此事件绑定才算成功。而之后页面动态添加的元素则不会绑定这个事件。<a id="more"></a><br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(selector).<span class="keyword">bind</span>(event,<span class="keyword">data</span>,<span class="function"><span class="keyword">function</span></span>)</div></pre></td></tr></table></figure></p>
<h2 id="二、live-die方法"><a href="#二、live-die方法" class="headerlink" title="二、live die方法"></a>二、live die方法</h2><p>live方法利用了事件代理的方法把监听器绑定到document，这样就即使是动态添加的事件也不需要重新绑定了。但是这个还是有一定问题的，他把事件监听放在document上，目标事件要层层冒泡才能触发，这显然是是影响性能浪费时间，不建议使用此方法。jQuery官方已宣布在1.7版本开始废弃，1.9版本移除live方法。那么事件委托就交给delegate。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(selector).live(event,<span class="keyword">data</span>,<span class="function"><span class="keyword">function</span></span>)</div></pre></td></tr></table></figure></p>
<h2 id="三、delegate-undelegate方法"><a href="#三、delegate-undelegate方法" class="headerlink" title="三、delegate undelegate方法"></a>三、delegate undelegate方法</h2><p>delegate方法是live方法的改进版。于bind方法不同，delegate方法显然就聪明多了，它可以让你自由的选择绑定监听的元素，我们可以选择里目标元素最近的父元素上，能让事件快速的冒泡上去，在第一时间处理。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(parentSelector).delegate(selector,event,<span class="keyword">data</span>,<span class="function"><span class="keyword">function</span></span>)</div></pre></td></tr></table></figure></p>
<h2 id="四、on-off方法"><a href="#四、on-off方法" class="headerlink" title="四、on off方法"></a>四、on off方法</h2><p>自 jQuery 版本 1.7 起，on() 方法是 bind()、live() 和 delegate()方法的代替品，用它可以代替bind,live,delegate方法，简化了书写。<code>$(selector).on(event,function)</code>代替bind方法。<br>官方推荐尽量使用on方法，其他这几个方法都是内部调用on方法的，直接使用on方法可以提高效率，所以我们可以用on方法代替其他几个方法。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(parentSelector).on(event,selector,<span class="keyword">data</span>,<span class="function"><span class="keyword">function</span></span>,map)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Jquery </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[写在前面的话]]></title>
      <url>/blog/2017/04/26/hexo-GitHub-Pages-Dropbox-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>从今天开始我的个人博客总算是初具模型了，虽然很简陋但也算是自己小窝了。对于建立自己个人博客，自己很久之前就是有这个想法的，但中间各种事(自己的拖延症的借口)，加上自己水平有限，就一拖再拖了。<br>临近毕业，正好赶上要作毕业设计，就突发奇想看看能不能做一个博客交差呢？即使不行，还可以督促自己完成构建个人博客，怎么算都是赚的。<a id="more"></a>于是就有了这个博客的雏形，还有感谢这个主题的创建者还有网上超牛的博主，他们的无私分享让我受益无穷(生活在当今世界真是幸运）。<br>当然这只是个初级版本，今后还会努力建设自己的小窝的。</p>
]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
